use uo;
use os;
use npc;
use cfgfile;

include ":ghaia:generic";
include ":ghaia:ghaia";
include ":ghaia:objective";
include ":ghaia:genericControl";

var me         := self();
var npccfgfile := NPC_GetNPCConfig(me);
var idlesnd1;
var idlesnd2;
var areasize;
var alert_allies := 0;
var flee_point   := 0.1;
var mystate      := INITIALIZING;

program NPCMonitor()
	genericControl();
endprogram

function CloseDistance( opponent )
	if (cint(npccfgfile.Ranged) || me.weapon.isBow())
		return CloseDistanceArcher(opponent);
	endif
	return CloseDistanceMeele(opponent);
endfunction

function CloseDistanceMeele( opponent )
	if ( GetObjProperty(me, "noclosecombat") == 1)
		return 0;
	endif

	var sleepdelay := 275 - me.run_speed;//(CInt(GetDexterity(me)) * 1.5);

	if (sleepdelay < 0)
		sleepdelay := 0;
	endif

   if (CoordinateDistance( me.x, me.y, opponent.x, opponent.y ) > 1)
      CalcPathAndMove(me, opponent, sleepdelay);
      return 0;
   else
	   return 1;
   endif  
endfunction

function CloseDistanceArcher(opponent)
	var sleepdelay := 275 - me.run_speed;

	if (sleepdelay < 0)
		sleepdelay := 50;
	endif

	var dist := CoordinateDistance(me.x, me.y, opponent.x, opponent.y);
	
	if (me.z > cint(opponent.z+15)) //checa se esta em cima de alguma torre
		if (!CheckLineofSight(me, opponent)) //IA para torres: Verifica se tem visão do oponente
			if (RandomInt(4) == 0 ) //se não tiver visão, tem 25% de mudar de alvo
				sleepms(sleepdelay);
				ChooseAnotherOpponent(me);
			endif
		endif
		sleepms(sleepdelay);
		return 0; //se estiver em cima de torres, não se move do lugar
	endif

	if (dist < 3 )
		RunAwayFrom(opponent);
		sleepms(sleepdelay);
	elseif (dist > 10)
		CalcPathAndMove(me, opponent, sleepdelay);
	else
		return 1;
	endif

	return 0;
endfunction

function lookAround()
  foreach npc in ListMobilesInLineOfSight(me, areasize)
    if( CanFight(me, npc) )
         Fight(npc);
    endif
    sleepms(2);
  endforeach
endfunction


function Fight(opponent, alerted := 0)
  // mystate := FIGHTING;
   if(opponent.serial == me.serial)
      SetWarMode(0);
      opponent := 0;
      return;
   endif
    
   set_priority(50);
   SetOpponent(opponent);
   DisableMainEvents();
   EnableCombatEvents();
   TurnToward(opponent);
   var loops := 0;
   var waittime := 0;
   var ev;

   if (!alerted && alert_allies) 
      AlertAllies(me, opponent); 
   endif

/*   var speech := GetConfigStringArray( npccfgfile, "InitCombatSpeech" );
   if (speech.size() > 0)
   if (RandomInt(100)  < 30) //sempre 30% de chance de falar
   Say(speech[RandomInt(speech.size()+1)]);
   endif
   endif
*/

   var dist;
   while( me && loops <= 140)
      if (me.dead || !opponent || opponent.concealed || opponent.hidden)
         break;
      elseif (opponent.dead)
         var exist_enemies := 0;
         foreach npc in ListMobilesInLineOfSight(me, areasize + 2)
            if( CanFight(me, npc) )
               exist_enemies := 1;
               break;
            endif
            sleepms(2);
         endforeach

         // Pra se afastar do corpo e o cara poder correr
         if (!exist_enemies)
            var corpo := opponent.GetCorpse();
            var end   := ReadGameClock() + 10;
            while (CoordinateDistance(me.x, me.y, corpo.x, corpo.y) < areasize + 5 && end > ReadGameClock())
               RunAwayFromLocation(corpo.x, corpo.y);
               sleepms(100);
            endwhile
         endif
         break;
      endif

      dist := CoordinateDistance(me.x, me.y, opponent.x, opponent.y);
      if ( (areasize >= 20 && dist > areasize) || (dist > 20 && areasize < 20) )
			break;
      endif

      //se eh boss e tem eventos
      if ( GetBossStruct(me) != error && isBoss(me) )
         var unique := GetBossStruct(me);
         foreach ce in (unique.combatevent)
               if (TS_GetCooldown(me, ce.name) == error)
               Start_Script(":ghaia:special/genericspecial" , array{me, ce});
               endif
         endforeach
      endif

      if (hasCombat())
         DoCombatSpecial(me); ////////////// SPECIALL
      endif

      // if ( (dist > 6) && ( CInt(npccfgfile.teleport) ) )
      //    teleport(me, opponent);
      // endif

      // if ( (dist >  CInt(npccfgfile.BreathRange)) && CInt(npccfgfile.BreathAttack) == 1 )
      //    FireBreath(me, opponent, dist);
      // endif

      // if ( (npccfgfile.WebRange) && (dist > npccfgfile.WebRange) )
      //    SpitWeb(me, opponent, dist);
      // endif
      if (me.my_template()["moriquendi"])
        var last_autoheal := cint(GetObjProperty(me, "demon_heal"));
        if (last_autoheal <= ReadGameClock())
          SetObjProperty(me, "demon_heal", ReadGameClock() + 10);
          HealFLS(me, 20);
        endif
      endif
   
      if(!CloseDistance(opponent))
         loops := loops + 1;
         waittime := 0;
      else
         loops := 0;
         waittime := 1;
      endif
      
      // checkFlee(opponent); //uncomment later
      
      ev := wait_for_event(waittime);
      if(ev.type == SYSEVENT_SPEECH)
         continue;
      endif

      case (ev.type)
         EVID_OPPONENTHEALED:
         SYSEVENT_DAMAGED: 
            //se ele receber dano de alguem mais proximo que o oponente ou se receber dano de alguem e o oponente não estiver acessivel
            /*(CoordinateDistance(me.x, me.y, ev.source.x, ev.source.y) < CoordinateDistance(me.x, me.y, opponent.x, opponent.y)) ||*/
            if (ev.source && (!CheckLineOfSight(me, opponent) || !opponent))
               if ( (opponent) && RandomInt(5) == 1 ) //se ainda existir o oponente so tem 25% de chance de mudar de alvo
                  opponent := ev.source;
                  SetOpponent(opponent);
                  TurnToward(opponent);
               elseif ( (!opponent) || (!CheckLineOfSight(me, opponent))) //mas se não tiver mais o oponent entao 100% de chance de mudar de alvo
                  opponent := ev.source;
                  SetOpponent(opponent);
                  TurnToward(opponent);
               endif
            endif

         SYSEVENT_ENGAGED: 
            if(ev.source && RandomInt(6) == 1)
               opponent := ev.source;
               SetOpponent(opponent);
               TurnToward(opponent);
            endif

         EVID_TAUNT:
            if(ev.source)
               opponent := ev.source;
               SetOpponent(opponent);
               TurnToward(opponent);		
            endif

         EVID_FLEE:
            if (ev.source)
               Flee(ev.source);
            endif

        //  EVID_PEACEMADE:
        //  //	sendsysmessage(ev.source, "peacemade");
        //     SetPeaceMade();
        //     return;
         EVID_COMBAT_MOVE:
            RunTowardLocation( ev.x, ev.y );
            if (CoordinateDistance(me.x, me.y, ev.x, ev.y) <= 1)
               clear_event_queue();
            endif
      endcase
      sleepms(5);
   endwhile

   DisableCombatEvents();
   EnableMainEvents();
   SetWarMode(0);
   SetOpponent(0);
   sleepms(1);
endfunction