use uo;
use os;
use npc;
use cfgfile;

include ":ghaia:generic";
include ":ghaia:ghaia";
include ":ghaia:objective";
include ":ghaia:genericControl";
include ":ghaia:habs";

var me         := self();
var npccfgfile := NPC_GetNPCConfig(me);
var idlesnd;
var areasize;
var custombehaviors;
var flee_point   := 0.1;
var mystate      := INITIALIZING;

program NPCMonitor()
	genericControl();
endprogram

function CloseDistance( opponent )
	if (cint(npccfgfile.Ranged) || me.weapon.isBow())
		return CloseDistanceArcher(opponent);
	endif
	return CloseDistanceMeele(opponent);
endfunction

function CloseDistanceMeele( opponent )
	if ( GetObjProperty(me, "noclosecombat") == 1)
		return 0;
   elseif (me.hidden && Distance(me, opponent) <= 1)
      me.hidden := 0;
	endif

	var sleepdelay := 275 - me.run_speed;//(CInt(GetDexterity(me)) * 1.5);

	if (sleepdelay < 0)
		sleepdelay := 0;
	endif

   if (CoordinateDistance( me.x, me.y, opponent.x, opponent.y ) > 1)
      CalcPathAndMove(me, opponent, sleepdelay);
      return 0;
   else
	   return 1;
   endif  
endfunction

function CloseDistanceArcher(opponent)
	var sleepdelay := 275 - me.run_speed;

	if (sleepdelay < 0)
		sleepdelay := 50;
	endif

	var dist := CoordinateDistance(me.x, me.y, opponent.x, opponent.y);
	
	if (me.z > cint(opponent.z+15) && !CheckLineofSight(me, opponent)) //checa se esta em cima de alguma torre
      me.setAggro(opponent.serial, -10);
      ChooseHighestOpponent(me, opponent);
		sleepms(sleepdelay);
		return 0; //se estiver em cima de torres, não se move do lugar
	endif

   var max_range := cint(npccfgfile.AttackMaxRange);
   var min_range := cint(npccfgfile.AttackMinRange);
   if (!max_range) max_range := 6; endif;
   if (!min_range) min_range := 3; endif;

	if (min_range != 1 && dist < cint(npccfgfile.AttackMinRange) )
		RunAwayFrom(opponent);
		sleepms(sleepdelay);
	elseif (dist > max_range)
		CalcPathAndMove(me, opponent, sleepdelay);
	else
		return 1;
	endif

	return 0;
endfunction

function lookAround()
   // if (RandomInt(5) == 1)
   //    PerformAction(me, ANIM_FIDGET_1);
   // endif

   foreach npc in ListMobilesNearLocationEx(me.x, me.y, me.z, areasize, LISTEX_FLAG_HIDDEN|LISTEX_FLAG_NORMAL);
      if( CanFight(me, npc) )
         Fight(npc);
      endif
      sleepms(2);
   endforeach
endfunction


function Fight(opponent, alerted := 0)
  // mystate := FIGHTING;
   if(opponent.serial == me.serial)
      SetWarMode(0);
      opponent := 0;
      return;
   endif
    
   set_priority(50);
   SetOpponent(opponent);
   DisableMainEvents();
   EnableCombatEvents();
   TurnToward(opponent);
   var loops := 0;
   var waittime := 0;
   var ev;

   if (!alerted) 
      AlertAllies(me, opponent); 
   endif

/*   var speech := GetConfigStringArray( npccfgfile, "InitCombatSpeech" );
   if (speech.size() > 0)
   if (RandomInt(100)  < 30) //sempre 30% de chance de falar
   Say(speech[RandomInt(speech.size()+1)]);
   endif
   endif
*/

   var dist;
   while( me && loops <= 140)
      sleepms(15);
      if (npccfgfile.Category == "moriquendi")
         if (GetGlobalProperty("dia") == "dia" && !InDungeon(me))
            ApplyRawDamage(me, 200);
            ApplyRawDamage(me, 200);
         endif
      endif

      if (me.dead || !opponent || opponent.concealed || opponent.hidden)
         // me.remAggro(opponent.serial);
         break;
      elseif (opponent.dead)
         //Somente checa se tem mais inimigo, se n se afsata do corpo.
         foreach npc in ListMobilesInLineOfSight(me, areasize + 2)
            if( CanFight(me, npc) )
               break;
            endif
            sleepms(2);
         endforeach

         // Pra se afastar do corpo e o cara poder correr
         var corpo := opponent.GetCorpse();
         var end   := ReadGameClock() + 10;
         while (CoordinateDistance(me.x, me.y, corpo.x, corpo.y) < areasize + 5 && end > ReadGameClock())
            RunAwayFromLocation(corpo.x, corpo.y);
            sleepms(100);
         endwhile
         break;
      endif

      dist := CoordinateDistance(me.x, me.y, opponent.x, opponent.y);
      if ( (areasize >= 20 && dist > areasize) || (dist > 20 && areasize < 20) )
         // if (JustTeleported(opponent))
         //    var area := ListItemsNearLocationOfType(me.x, me.y, me.z, 10, 25091);
         //    if (area.size() < 1)
         //       break;
         //    else
         //       var item := area[1];
         //       NpcGoTo(item, 2);
         //    endif
         // else
            break;
         // endif
      endif

      //se eh boss e tem eventos
      if ( GetBossStruct(me) != error && isBoss(me) )
         var unique := GetBossStruct(me);
         foreach ce in (unique.combatevent)
               if (TS_GetCooldown(me, ce.name) == error)
               Start_Script(":ghaia:special/genericspecial" , array{me, ce});
               endif
         endforeach
      endif

      if (hasCombat())
         DoCombatSpecial(me); ////////////// SPECIALL
      endif

      // UseHabs();

      // if (npccfgfile.Category == "moriquendi")
      //   var last_autoheal := cint(GetObjProperty(me, "demon_heal"));
      //   if (last_autoheal <= ReadGameClock())
      //     SetObjProperty(me, "demon_heal", ReadGameClock() + 2);
      //     HealFLS(me, 25);
      //   endif
      // endif
   
      if(!CloseDistance(opponent))
         loops := loops + 1;
         waittime := 0;
      else
         loops := 0;
         waittime := 1;
      endif
      
      ev := wait_for_event(waittime);
      if(ev.type == SYSEVENT_SPEECH)
         continue;
      endif
      
      case (ev.type)
         EVID_OPPONENTHEALED:
            if (!ev.source)
               continue;
            endif

            if (ev.target == opponent)
               me.setAggro(ev.source.serial, 5);
            endif
            ChooseHighestOpponent(me, opponent, ev.source);
         SYSEVENT_DAMAGED: 
            if (!ev.source)
               continue;
            endif
            me.setAggro(ev.source.serial, cint(ev.damage/2)+1+cint(ev.source.getToughness()));
            ChooseHighestOpponent(me, opponent, ev.source);
            /*(CoordinateDistance(me.x, me.y, ev.source.x, ev.source.y) < CoordinateDistance(me.x, me.y, opponent.x, opponent.y)) ||*/
            // if (ev.source && (!CheckLineOfSight(me, opponent) || !opponent))
            //    if ( (opponent) && RandomInt(5) == 1 ) //se ainda existir o oponente so tem 25% de chance de mudar de alvo
            //       opponent := ev.source;
            //       SetOpponent(opponent);
            //       TurnToward(opponent);
            //    elseif ( (!opponent) || (!CheckLineOfSight(me, opponent))) //mas se não tiver mais o oponent entao 100% de chance de mudar de alvo
            //       opponent := ev.source;
            //       SetOpponent(opponent);
            //       TurnToward(opponent);
            //    endif
            // endif

         SYSEVENT_ENGAGED:
            me.setAggro(ev.source.serial, 5);
            ChooseHighestOpponent(me, opponent, ev.source);

         EVID_TAUNT:
            me.setAggro(ev.source.serial, 20);
            ChooseHighestOpponent(me, opponent, ev.source);

         EVID_FLEE:
            if (ev.source)
               Flee(ev.source);
            endif

         EVID_PEACEMADE:
         //	sendsysmessage(ev.source, "peacemade");
            SetPeaceMade();
            return;
         EVID_COMBAT_MOVE:
            RunTowardLocation( ev.x, ev.y );
            if (CoordinateDistance(me.x, me.y, ev.x, ev.y) <= 1)
               clear_event_queue();
            endif
      endcase
   endwhile

   DisableCombatEvents();
   EnableMainEvents();
   SetWarMode(0);
   SetOpponent(0);
   sleepms(1);
endfunction

function JustTeleported(mobile)
	var tele_time := CInt(GetObjProperty(mobile, "#Teleported"));
	if ( tele_time > ReadMillisecondClock()-500 )
		// Mobile just teleported. Too soon to teleport again.
		return 1;
	else
		// Safe to teleport the mobile
		return 0;
	endif
endfunction