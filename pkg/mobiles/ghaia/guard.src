use uo;
use os;
use npc;
use util;
use guilds;

include ":attributes:attributes";
include "include/sysEvent";
include "include/say";
include ":mounts:mounts";
include ":taming:taming";
include ":tn:cooldown";
include ":ghaia:generic";
include ":ghaia:objective";

set_script_option(SCRIPTOPT_CAN_ACCESS_OFFLINE_MOBILES, 1);

const LOCKPICK_EVENT := 0x78455;
const CERCA_EVENT := 0x78456;

var pack_animals   := array{291, 292};
var me             := self();
var idlesnd, custombehaviors, personality, npccfgfile;
var following, fighting, warning, patrolling;
var warn_type, warn_tries, warn_opt := 0;
var wait_time := 10;
var tame_difficulty := 0;
var guild, guild_leader, guild_laws, fix_location;
var tools := array{0xec4, 0x13e3, 0xFB4, 0xFB5, 0x13f6, 0xe85, 0xf43, 0xec2, 0x1F020};

//Custom events
const FOLLOW_CMD     := 0xA001;
const ATTACK_CMD     := 0xA002;
const NEW_MASTER_CMD := 0xA003;
const GO_LOC_CMD     := 0xA008;

function EnableGuardMainEvents()
   EnableEvents(SYSEVENT_SPEECH, 10);
   EnableEvents(SYSEVENT_ENGAGED);
   EnableEvents(SYSEVENT_DAMAGED);
   // EnableEvents(SYSEVENT_DOUBLECLICKED, 5);
   EnableEvents(SYSEVENT_ITEM_GIVEN, 2);
   EnableEvents(SYSEVENT_ENTEREDAREA, 5);
   DisableEvents(SYSEVENT_OPPONENT_MOVED);
endfunction

function DisableGuardMainEvents()
   DisableEvents(SYSEVENT_SPEECH);
   DisableEvents(SYSEVENT_ENGAGED);
   DisableEvents(SYSEVENT_DAMAGED);
   DisableEvents(SYSEVENT_ITEM_GIVEN);
   // DisableEvents(SYSEVENT_DOUBLECLICKED);
   DisableEvents(SYSEVENT_OPPONENT_MOVED);
   DisableEvents(SYSEVENT_ENTEREDAREA);
endfunction

function HasEnemyNear(what)
   var mobile_list := ListMobilesNearLocationEx(what.x, what.y, LIST_IGNORE_Z, 8, LISTEX_FLAG_NORMAL|LISTEX_FLAG_NPC_ONLY);
   var enemy_near := 0;
   foreach mob in mobile_list
      if (mob.alignment == 2 && mob != what && mob != me)
         enemy_near := 1;
         break;
      endif
      sleepms(2);
   endforeach

   if (enemy_near)
      return 1;
   endif
endfunction

function CheckPlayer(who)
   // Printtext(who, "{} is checking you".format(me.name));
   if (who.npctemplate)
      if (who.alignment == 2)
         warning   := 0;
         warn_type := 0;
         Fight(who);
         return;
      endif
   endif

   var privs := guild.GetProp(cstr(who.serial));
   var is_leader := (who.serial == guild_leader);
   // if (is_leader || privs.above_guards)
   //    return 0;
   // elseif (GetCooldown(me, "recentcheck_{}".format(who.serial)))
   //    return 0;
   // endif

   var hostiles := ListHostiles(who, 8);
   foreach mob in hostiles
      if (GetObjProperty(mob, "guild") == guild.guildid || mob.guildid == guild.guildid)
         Fight(mob);
         return 0;
      endif
      sleepms(2);
   endforeach

   foreach law in guild_laws
      case (law.type)
         "nofight": 
            if (who.warmode == 1)
               if (!HasEnemyNear(who))
                  warning := who;
                  warn_type := 1;
               endif
            endif
            break;
         "noweapon":
            if (!(who.weapon.objtype in tools))
               if (!HasEnemyNear(who))
                  warning := who;
                  warn_type := 3;
               endif
            endif
            break;
         "noitem":
            if (CheckItem(who, law.opt))
               warning := who;
               warn_type := 4;
               warn_opt := law.opt;
            endif
      endcase
      sleepms(2);
   endforeach

   SetCooldown(me, "recentcheck_{}".format(who.serial), 5);
endfunction

function Checkitem(what, itemobj)
   var itemlist := ListEquippedItems(what);
   foreach item in itemlist
      if (item.objtype == itemobj.objtype)
         return itemobj;
      endif
      sleepms(2);
   endforeach
endfunction

program NPCMonitor()
   EnableGuardMainEvents();
   Setup();
   set_critical(1);
   SetWarMode( 0 );
   Set_Event_Queue_Size(20);
   wait_time := 10;
   SetAnchor(0, 0, 0, 0);
   while (me)
      if (GetObjProperty(me, "objloc") != error)
         DoObjective();
      endif

      if (warning)
         wait_time := 0;
      endif

      if ( wait_time < 1 )
         sleepms(10);
      endif

      Fight();
      PetFollow();
      WarnPlayer();

      if (!following && !fighting && !warning)
         var listmobiles := ListMobilesNearLocation( me.x, me.y, me.z, 8, me.realm);
         foreach mob in listmobiles
            sleepms(2);
            if (mob == me)
               continue;
            endif
            if (CheckPlayer(mob))
               wait_time := 0;
               break;
            endif
         endforeach
      endif

      if (!following && !fighting && !warning)
         if (ListMobilesNearLocationEx(me.x, me.y, LIST_IGNORE_Z, 15, LISTEX_FLAG_NORMAL|LISTEX_FLAG_HIDDEN|LISTEX_FLAG_PLAYERS_ONLY).size() < 1)
            wait_time := 2000;
         else
            wait_time := 5;
         endif
         warn_tries := 0;
      endif

      var ev := Wait_For_Event(wait_time);
      case(ev.type)
         SYSEVENT_ENGAGED:
         SYSEVENT_DAMAGED:
            if (!following && !fighting)
               Fight(ev.source);
            endif
            break;
         LOCKPICK_EVENT:
            if (FindInArray(guild_laws, struct{"type" := "nolockpick" }))
               PrintText(me, "Ei! O que pensa que está fazendo?");
               Fight(ev.source);
               disableWarn();
            endif
            wait_time := 0;
         CERCA_EVENT:
            if (FindInArray(guild_laws, struct{"type" := "nocerca" }))
               PrintText(me, "Ei! O que pensa que está fazendo?");
               var storeloc := struct{ "x" := ev.source.x, "z" := ev.source.z, "y" := ev.source.y };
               PetGoTo(ev.last_loc, 2);
               MoveObjectToLocation(me, storeloc.x, storeloc.y, storeloc.z, me.realm, MOVEOBJECT_FORCELOCATION);
               Fight(ev.source);
               disableWarn();
            endif
            wait_time := 0;
            break;
         SYSEVENT_ENTEREDAREA:
            CheckPlayer(ev.source);
            wait_time := 0;
            break;
         EVID_TAUNT:
            if(ev.source && ev.source in ListHostiles(me, 5))
               Fight(ev.opponent);
            endif
            break;
         EVID_FLEE:
            Flee(ev.source);
            break;
         EVID_DOOBJECTIVE:
            if (ev.destiny)
               PetGoTo(ev.destiny, ev.move_type);
            endif
            wait_time := 0;
            break;
         SYSEVENT_SPEECH:
            ResolveSpeech(ev);
         // SYSEVENT_DOUBLECLICKED:
         //    if ( ev.source == me.master || ev.source.cmdlevel >= 3 )
         //       if( (Distance(ev.source, me) > 1) )
         //          ProcessDoubleClick(ev);
         //       elseif ( me.graphic in pack_animals )
         //          OpenPack(ev);
         //       endif
         //    endif
         // SYSEVENT_ITEM_GIVEN:
         //    TakeItem(ev);

         // Custom events
            break;
         FOLLOW_CMD:
            PetFollow(ev.targ);
            break;
         ATTACK_CMD:
            Fight(ev.targ);
            break;
         default:
            wait_time := 5;
      endcase

      sleepms(10);
   endwhile
endprogram


function ResolveSpeech(ev)
   var text := lower(ev.text);
   var name := lower(me.name);

   var privs := guild.GetProp(cstr(ev.source.serial));
   var is_leader := (ev.source.serial == guild_leader);
   if (!privs.above_guards && !is_leader)
      return;
   elseif(!text[name] && !text["todos"])
      return;
   endif

   var targ;
   if (text["-me"])
      targ := ev.source;
   endif

   var allevent;

   /// Attack command
   if (text["mate"] || text["ataque"] || text["prenda"])
      PrintText(me, "As suas ordens");
      targ := target(ev.source, TGTOPT_HARMFUL + TGTOPT_CHECK_LOS);
      disableWarn();
      Fight(targ);
      allevent := struct{ targ := targ, type := ATTACK_CMD };

   /// Stop Command
   elseif (text["pare"])
      PrintText(me, "Sim senhor");
      disableWarn();
      following  := 0;
      fighting   := 0;
      warning := 0;

   /// Follow Command
   elseif (text["siga"])
      PrintText(me, "As suas ordens");
      disableWarn();
      if (!targ)
         targ := target(ev.source);
      endif
      PetFollow(targ);
      allevent := struct{ targ := targ, type := FOLLOW_CMD };
   elseif (text["parar"] && text["patrulha"])
      PrintText(me, "Sim senhor.");
      patrolling := 0;
      EraseObjProperty(me, "patrolling");

   elseif (text["patrulh"])
      PrintText(me, "Informe a rota senhor");
      disableWarn();
      following  := 0;
      fighting   := 0;
      warning := 0;
      patrolling := 0;
      
      SendSysMessageEx(ev.source, "Escolha a rota de patrulha. Não podem ter mais de 20 tiles entre elas.");
      var targ := TargetCoordinates(ev.source);
      if (!targ) return SendSysMessageEx(ev.source, "Cancelado"); endif
      patrolling := array{targ};

      SendSysMessageEx(ev.source, "Escolha a próxima rota de patrulha. Não podem ter mais de 20 tiles entre elas.");
      targ := TargetCoordinates(ev.source);
      if (!targ) 
         patrolling := 0;
         return SendSysMessageEx(ev.source, "Cancelado"); 
      endif
      patrolling.append(targ);

      EraseObjProperty(me, "fix_loc");
      SetObjProperty(me, "patrolling", patrolling);
      PrintText(me, "Irei iniciar minha patrulha");
   elseif (text["mant"] && text["posição"])
      PrintText(me, "Sim senhor.");
      patrolling := 0;
      fix_location := struct{ "x" := ev.source.x, "z" := ev.source.z, "y" := ev.source.y, facing := ev.source.facing };

      EraseObjProperty(me, "patrolling");
      SetObjProperty(me, "fix_loc", fix_location);
   endif

   if (text["todos"] && allevent)
      AllCommand(allevent);
   endif
endfunction

function AllCommand(ev)
   var event := struct;
   event.+type := ev.type;
   event.+source := me;
   event.+targ := ev.targ;

   foreach mobile in(ListMobilesNearLocation( me.x, me.y, me.z, 8, me.realm))
      if ( GetObjProperty(mobile, "guild") == guild.guildid)
         SendEvent(mobile, event);
      endif

      sleepms(2);
   endforeach
endfunction

function disableWarn()
   warn_type  := 0;
   warn_tries := 0;
   warning    := 0;
endfunction

function WarnPlayer()
   if (fighting || !warning || following)
      return;
   elseif (warning.concealed || warning.hidden || warning.dead)
      disableWarn();
      return;
   endif 
   
   wait_time := 0;
   if (Distance(me, warning) <= 3)
      PetMovement(warning, 1);
      wait_time := 1;
   else
      PetMovement(warning, 2);
   endif

   if (GetCooldown(me, "last_warn_{}".format(warning.serial)))
      return;
   endif

   // PrintText(me, "Looking what to warn");
   case (warn_type)
      1: //nofight
         if (!warning.warmode)
            PrintText(me, "Muito bem.");
            disableWarn();
            return;
         endif
         if (warn_tries == 0)
            PrintText(me, "Não é permitido brigar aqui");
            PrintText(me, "Pare com esta atitude agora mesmo!");
         else
            var rand_msg := RandomInt(4);
            case (rand_msg)
               0:1: PrintText(me, "Vamos lá, pare com isso"); break;
               2: PrintText(me, "Não me obrigue a tomar uma atitude"); break;
               3: PrintText(me, "Estou falando sério, sem combate aqui!"); break;
            endcase
         endif

         break;
      3: //noweapon
         if (warning.weapon.objtype in tools)
            PrintText(me, "Muito bem.");
            disableWarn();
            return;
         endif

         if (warn_tries == 0)
            PrintText(me, "Não é permitido usar armas aqui");
            PrintText(me, "Guarde-a agora mesmo!");
         else
            var rand_msg := RandomInt(4);
            case (rand_msg)
               0:1: PrintText(me, "Vamos lá, guarde esta arma"); break;
               2: PrintText(me, "Não me obrigue a tomar uma atitude"); break;
               3: PrintText(me, "Estou falando sério, guarde esta arma!"); break;
            endcase
         endif
         break;
      4: //noitem
         if (!CheckItem(warning, warn_opt))
            PrintText(me, "Muito bem.");
            disableWarn();
            return;
         endif

         if (warn_tries == 0)
            PrintText(me, "Não é permitido usar {} aqui".format(warn_opt.name));
            PrintText(me, "Guarde-a agora mesmo!");
         else
            var rand_msg := RandomInt(4);
            case (rand_msg)
               0:1: PrintText(me, "Vamos lá, guarde {}".format(warn_opt.name)); break;
               2: PrintText(me, "Não me obrigue a tomar uma atitude"); break;
               3: PrintText(me, "Estou falando sério, guarde isso agora mesmo!"); break;
            endcase
         endif
         break;
      5: //nocerca
         break;
      5: //norace
         break;
   endcase

   if (warn_tries >= 5)
      Fight(warning);
      disableWarn();
   endif

   // PrintText(me, "warned");
   SetCooldown(me, "last_warn_{}".format(warning.serial), 2);
   warn_tries += 1;
endfunction

function Fight(opponent := 0)
   if (opponent)
      // PrintText(me, "I will engage".format(opponent.name));
      if ( opponent == me || opponent == fighting || !opponent.IsA(POLCLASS_MOBILE) || guild_leader == opponent.serial )
         return;
      endif

      fighting := opponent;
      disableWarn();
      SetOpponent(opponent);
      SetWarMode(1);
      wait_time := 0;
      return;
   endif

   if (!fighting)
      SetOpponent(0);
      SetWarMode(0);
      return;
   endif

   // PrintText(me, "Engaged");
   if (fighting.concealed || fighting.hidden || fighting.dead || Distance(me, fighting) > 15)
      var hostiles := ListHostiles( me, 8, LH_FLAG_LOS);
      if (!hostiles[1])
         fighting := 0;
         SetOpponent(0);
         SetWarMode(0);
         return;
      else
         fighting := hostiles[1];
      endif
   endif

   var range := 1;
   var minrange := 0;
   if (npccfgfile.AttackMaxRange)
      range := cint(npccfgfile.AttackMaxRange);
   endif

   if (npccfgfile.AttackMinRange)
      minrange := cint(npccfgfile.AttackMinRange);
   endif

   var dist := CoordinateDistance(me.x, me.y, fighting.x, fighting.y);
   if (dist > range)
      CalcPathAndMove(me, fighting, 275 - me.run_speed);
   elseif (dist < minrange)
      RunAwayFrom(fighting);
   endif

   wait_time := 0;
endfunction

function PetFollow(character := 0)
   if (character)
      if ( character == me || character == fighting || !character.IsA(POLCLASS_MOBILE) )
         return;
      endif
      patrolling := 0;
      warning := 0;
      following := character;
      return;
   elseif (fighting || warning || !following)
      return;
   endif

   var dist := Distance(me, following);

   if( dist <= 2 )
      wait_time := 1;
   elseif( dist > 25 )
      following := 0;
      wait_time := 120;
   elseif ( dist > 4 )
      RunTowardLocation( following.x, following.y );
      wait_time := 0;
   else
      WalkTowardLocation( following.x, following.y );
      wait_time := 0;
   endif
endfunction

function SendToPrison()

endfunction

function StoreWeapon(reverse := 0)

endfunction

function EatSomething()
   var random_food := CreateItemInBackpack(me, "banana");
   UseItem(random_food, me);
endfunction

function CanFight(me, mob)
   var hostiles := ListHostiles( me, 8, LH_FLAG_LOS);

   if (mob in hostiles)
      return 1;
   endif

   return 0;
endfunction

function PetMovement(what, move_mode)
   if (!CheckLosAt(me, what.x, what.y, what.z) || CanWalk("L", me.x, me.y, me.z, me.facing) == error) //se n¿o consegue correr direto
		var path := GetObjProperty(me, "path"); //procura se ja calculou o path
		var last_loc := GetObjProperty(me, "#enemy_last_loc"); //procura se ja calculou o path
		
      if (path == error || ( last_loc && !(what in ListMobilesNearLocation(last_loc.x, last_loc.y, last_loc.z, 3)) )) //se n¿o calculou
         var flags := FP_IGNORE_MOBILES;
         if ( cint(GetObjProperty(me, "ignoredoor")) || cint(GetObjProperty(me, "opendoor")) )
            flags := flags| FP_IGNORE_DOORS;
         endif
         path := FindPath(  me.x, me.y, me.z, what.x, what.y, what.z, me.realm, flags, 15); //calcula o path
         
         if (!path[1] || !path || path == error)
            sleepms(2);
            what := 0;
         else
            if (move_mode == 2)
               RunTowardLocation( path[1].x, path[1].y ); //anda na direcao
            else
               WalkTowardLocation( path[1].x, path[1].y ); //anda na direcao
            endif
				path.erase(1); //deleta a coordenada e vai pra proxima
            set_critical(1);
            SetObjProperty(me, "path", path);
            SetObjProperty(me, "#enemy_last_loc", array{what.x, what.y, what.z});
            set_critical(0);
         endif
		endif

      var coord := path[1]; //pega a primeira coordenada
      if (coord); 
         var coordtry := GetObjProperty(me, "#coordtry");
         if (coordtry != error && coordtry[1] != coord)
            SetObjProperty(me, "#coordtry", array{coord, ReadGameClock()+5 }); 
         endif
         if (move_mode == 2)
            RunTowardLocation( coord.x, coord.y ); //anda na direcao
         else
            WalkTowardLocation( coord.x, coord.y ); //anda na direcao
         endif
         sleepms(2);
         Opendoors(me); //tenta abrir possiveis portas
         if (CoordinateDistance(me.x, me.y, coord.x, coord.y) <= 1) //se chegou onde devia 
            path.erase(1); //deleta a coordenada e vai pra proxima
            if (path[1])
               SetObjProperty(me, "path", path);
            else
               EraseObjProperty(me, "path");
            endif
         else // se n¿o consegue chegar na coord 
            if ( coordtry[2] > ReadGameClock()) //se ta tentando chegar la a mais de 5 segundos
               EraseObjProperty(me, "path"); //deleta o path atual
               what := 0;
            endif
         endif
      else
         if (move_mode == 2)
            RunToward( what );
         else
            WalkToward( what );
         endif
         RunToward( what );
         sleepms(2);
      endif
   else
      EraseObjProperty(me, "path");
      EraseObjProperty(me, "#enemy_last_loc");
      if (move_mode == 2)
         RunToward( what );
      else
         WalkToward( what );
      endif
      sleepms(2);
	endif
endfunction

function PetGoTo(destiny, move_type)
   var flags := FP_IGNORE_MOBILES;
   if ( cint(GetObjProperty(me, "ignoredoor")) || cint(GetObjProperty(me, "opendoor")) )
      flags := flags| FP_IGNORE_DOORS;
   endif
   var path := FindPath(  me.x, me.y, me.z, destiny.x, destiny.y, destiny.z, me.realm, flags, 12); //calcula o path
   var sleepdelay := 275 - me.run_speed;//(CInt(GetDexterity(me)) * 1.5);
   foreach coord in path
      if (move_type == 1)
         WalkTowardLocation( coord.x, coord.y ); //anda na direcao
      else
         RunTowardLocation( coord.x, coord.y ); //anda na direcao
      endif
      OpenDoors(me);
      sleepms(sleepdelay);
   endforeach
endfunction

function Setup()
   printtext(me, "SETUP");
   var guildid := GetObjProperty(me, "guild");

   if (guildid)
      printtext(me, "guildid found {}".format(guildid));
      guild := FindGuild(guildid);
      if (!guild)
         ApplyRawDamage(me, 600);
      endif
   else
      printtext(me, "waiting for guild ID");
      sleep(5);
      Setup();
   endif

   if ( !me.backpack )
      var new_pack := CreateItemAtLocation(me.x, me.y, me.z, "backpack", 1);
      EquipItem(me, new_pack);
   endif

   guild_leader := guild.getProp("leader");
   guild_laws := guild.getProp("laws");
   if (!guild_laws)
      guild_laws := array{};
   endif
   printtext(me, "guild_laws {}".format(guild_laws));

   patrolling := GetObjProperty(me, "patrolling");
   fix_location := GetObjProperty(me, "fix_loc");

   me.facing := me.facing+1;
   me.cmdlevel := 2;
endfunction