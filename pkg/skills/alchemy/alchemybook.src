

use uo;

include ":timedScripts:timedScripts";
include ":gumps:gumps";
include ":gumps:yesno";
include ":gumps:requestgump";
include ":tn:tngumps";
include ":magery:tnmagery";
include "include/say";
include ":containers:containers";
include ":charactercreation:habilidades";

program book(who, book)

	//Edmond - 15/02/2012
	var serialid := GetObjProperty(book, "serialid");
	if (serialid != error)
		if (serialid != who.serial && who.cmdlevel < 3)
			SendSysMessageEx(who, "Voce nao entende esse livro.", SSM_FAIL);
			return 1;
		endif
	endif

	var book_gump := CreateRunebookGump(book, who);
	var result := GFSendGump(who, book_gump);

	var spell := result[0] - 100;
	
	var spells := GetObjProperty(book, "recipes");
	
	if (spells[spell])
			MakePotion ( spells[spell].id,  who);
			//Start_Script("cast_spell", {who, spells[spell], 0});
	endif

endprogram

const SOUND_EFFECT_GRIND := 0x243;
const UOBJECT_EMPTY_BOTTLE := 0x0f0e;
const SOUND_EFFECT_POUR := 0x241;

function MakePotion ( pot, who)

	var recipes := ReadConfigFile(":alchemy:config/recipes");
	var difficulty := recipes[pot].skill;
	var magic := cint(recipes[pot].magic);
	var strength := cint(recipes[pot].strength);
	var habilidade := recipes[pot].habilidade;

	//sendsysmessage(who, "magic  " + magic + " skill " + difficulty) ;

	var mortar := 0;
	foreach item in (EnumerateItemsInContainer( who.backpack))
		if (item.graphic == 3739)
			if (ReserveItem(item))
				mortar := 1;
				break;
			endif
		endif
		sleepms(5);
	endforeach
	if (!mortar)
		SendsysMessageEx(who, "Voce precisa de um almofariz.", SSM_FAIL);
		return;
	endif
	if (habilidade && !TemHabilidade(who, habilidade))
		SendsysMessageEx(who, "Voce precisa da habilidade "+habilidade+".", SSM_FAIL);
		return;
	endif

	var reagent_costs := GetConfigStringDictionary( recipes[pot], "Reg" );
//	sendsysmessage(who, " " + reagent_costs);
	var amount;
	foreach reag in (reagent_costs.keys())

		amount := CInt( reagent_costs[reag] );
		if (!amount)
			amount := 1;
		endif
		var objtype := cint(reag);
		var dictToAmount := dictionary; //variavel pra ser usada na funcao abaixo
		dictToAmount["objtype"] := objtype;
		var amountinpack := AmountInContainer(who.backpack, dictToAmount);
		//sendsysmessage(who, "reag " + reag + " objtype " + objtype + " pack " + amountinpack);
		if (amountinpack  < amount )
			SendSysMessage(who, "Voce nao possui todos os materiais.");
			return 0;
		endif
		sleepms(2);
	endforeach

	foreach reag in (reagent_costs.keys())
		amount := CInt( reagent_costs[reag] );
		if (temHabilidade(who, "Medida Certa"))
			if (randomInt(100) < 20)
				amount := amount -1;
			endif
		endif
		if (!amount)
			amount := 1;
		endif
		ConsumeSubstance(who.backpack, reag, amount);
		sleepms(2);
	endforeach


	var loop := 0;

	while(loop < 3)
		PlaySoundEffect(who, SOUND_EFFECT_GRIND);
		PrintText(who, "*preparando um extrato*");
		sleep(1);
		loop := loop + 1;
	endwhile
      
    
	if(SkillCheck(who, ALCHEMY, difficulty) > 0) 
		var hasbottle:= 0;
		set_critical(1);
		foreach item in EnumerateItemsInContainer(who.backpack)
			if((item.objtype == UOBJECT_EMPTY_BOTTLE) && (item.container.objtype != 0x1940))
				if(SubtractAmount(item, 1))
					hasbottle := 1;
					break;
				endif
			endif
		endforeach
		set_critical(0);

		if(hasbottle)
			var thing;
			if (!magic)//se nao tiver o flag magic como as tintas, cria o item
				thing := CreateItemInBackpack(who, pot, 1);
			else //se nao cria so o extrato
				thing := CreateItemInBackpack(who, 0xcfff, 1);
				SetObjProperty(thing, "extrato", pot);
				if (strength)
					SetObjProperty(thing, "strength", strength);
				endif
				if (GetObjProperty(who, "extratoinstantaneo"))
					SendSysMessageEx(who, "Voce fez um extrato instantaneo.", SSM_INFO);
					var pocao := GetObjProperty(thing, "pocao");
       					var pot := CreateItemInBackpack(who, pocao, 1);
					SetObjProperty(pot, "strength", cint(GetObjProperty(thing, "strength")));
					DestroyItem(thing);
					EraseObjProperty(who, "extratoinstantaneo");
				endif
			endif
			SetObjProperty(thing, "crafterskill", AP_GetSkill(who, ALCHEMY) );
			PlaySoundEffect(who, SOUND_EFFECT_POUR);
			SendSysMessageEx(who, "Voce fez a pocao e a guardou na sua mochila.", SSM_INFO);
			return;
        
		else
			SendSysMessageEx(who, "Voce nao tem frascos.", SSM_FAIL);
			return;
		endif
      
	else
		PlaySoundEffect(who, SOUND_EFFECT_POUR);
		SendSysMessageEx(who, "Voce nao conseguiu fazer nada com isso.", SSM_FAIL);
		return;
	endif
endfunction


function CreateRunebookGump(book, who)
	var rune_list := GetObjProperty(book, "recipes");
	if( TypeOf(rune_list) != "Array" )
		rune_list := array{};
		SetObjProperty(book, "recipes", rune_list);
	endif

	var book_gump := GFCreateGump();
// Begin Page 0 Setup
	GFGumpPic(book_gump, 72, 5, 11055);
	GFGumpPic(book_gump, 125, 50, 57);
	GFGumpPic(book_gump, 145, 50, 58);
	GFGumpPic(book_gump, 160, 50, 58);
	GFGumpPic(book_gump, 175, 50, 58);
	GFGumpPic(book_gump, 190, 50, 58);
	GFGumpPic(book_gump, 205, 50, 58);
	GFGumpPic(book_gump, 220, 50, 58);
	GFGumpPic(book_gump, 230, 50, 59);
	GFGumpPic(book_gump, 290, 50, 57);
	GFGumpPic(book_gump, 310, 50, 58);
	GFGumpPic(book_gump, 325, 50, 58);
	GFGumpPic(book_gump, 340, 50, 58);
	GFGumpPic(book_gump, 355, 50, 58);
	GFGumpPic(book_gump, 370, 50, 58);
	GFGumpPic(book_gump, 385, 50, 58);
	GFGumpPic(book_gump, 395, 50, 59);

	/*GFAddButton(book_gump, 130, 187, 2225, 2225, GF_PAGE_BTN, 2);
	GFAddButton(book_gump, 165, 187, 2226, 2226, GF_PAGE_BTN, 3);
	GFAddButton(book_gump, 200, 187, 2227, 2227, GF_PAGE_BTN, 4);
	GFAddButton(book_gump, 235, 187, 2228, 2228, GF_PAGE_BTN, 5);
	GFAddButton(book_gump, 300, 187, 2229, 2229, GF_PAGE_BTN, 6);
	GFAddButton(book_gump, 335, 187, 2230, 2230, GF_PAGE_BTN, 7);
	GFAddButton(book_gump, 370, 187, 2231, 2231, GF_PAGE_BTN, 8);
	GFAddButton(book_gump, 405, 187, 2232, 2232, GF_PAGE_BTN, 9);*/
//	GFHTMLArea(book_gump,  140, 40, 80, 18, "Charges:");
//	GFHTMLArea(book_gump,  300, 40, 100, 18, "Max Charges:");
//	GFHTMLArea(book_gump,  220, 40, 80, 18, charges);
//	GFHTMLArea(book_gump,  400, 40, 100, 18, max_charges);
// End Page 0 Setup

// Begin Page 1 Setup
	GFPage(book_gump, 1);
	//GFAddButton(book_gump, 125, 15, 2472, 2473, GF_CLOSE_BTN, 50);
	GFHTMLArea(book_gump, 135, 22, 100, 18, "Solve Et Coagula");
	GFAddButton(book_gump, 393, 14, 2206, 2206, GF_PAGE_BTN, 2);
	
	var pOX := 130;
	var pOY := 70;
	var rune_pos         := 1;
	foreach rune in rune_list
		GFAddButton(book_gump, pOX, pOY, 2103, 2104, GF_CLOSE_BTN, 100+rune_pos);
		rune_pos+=1;
		pOY+=15;
		if (pOY >165)
			pOY := 70;
			pOX := 290;
		endif
	endforeach
	
// End Page 1 Setup

// Below you will notice in the loop, there are entries put BACK into page
// 1. Do not worry, we run an Optimize function on the gump to put all
// of those BACK into the initial Page 1 section we just made to keep our
// gump's arrays looking nice and clean.

	pOX := 145;
	pOY := 65;
	rune_pos         := 1;

	for i := 2 to 9
		GFPage(book_gump, i);
		GFAddButton(book_gump, 120, 14, 2205, 2205, GF_PAGE_BTN, (i-1));
		if(i != 9)
			GFAddButton(book_gump, 393, 14, 2206, 2206, GF_PAGE_BTN, (i+1));
		endif

		var rune_entry := rune_list[rune_pos];
		//WriteSpellInfo(rune_entry);
		rune_entry.description := "<BASEFONT COLOR=#000066>" +  cstr(rune_entry.description) ;
		if( TypeOf(rune_entry) == "Struct" )
			if( rune_entry.name )
				// This puts the rune in page 1's list.
				GFPage(book_gump, 1);
				GFTextCrop(book_gump, pOX,  pOY, 115, 17, 995, rune_entry.name);
				GFPage(book_gump, i);

				//GFHTMLArea(book_gump, 160, 15, 100, 18, rune_entry.name);
				GFTextCrop(book_gump, 145, 31, 100, 18, 995, rune_entry.name);
				GFHTMLArea(book_gump, 140, 68, 120,  130, cstr(rune_entry.description), 0, 1);

			endif
		else
			GenerateEmptySide(book_gump, 1, pOX, pOY, i);
		endif
                rune_pos := rune_pos + 1;
		pOY := pOY + 15;
		if( pOY > 165 )
			pOY := 65;
			pOX := 305;
		endif

		rune_entry := rune_list[rune_pos];
		//WriteSpellInfo(rune_entry);
		 rune_entry.description := "<BASEFONT COLOR=#000066>" +  cstr(rune_entry.description);

		if( TypeOf(rune_entry) == "Struct" )
			if( rune_entry.name )
				// This puts the rune in page 1's list.
				GFPage(book_gump, 1);
				GFTextCrop(book_gump, pOX,  pOY, 115, 17, 995, rune_entry.name);
				GFPage(book_gump, i);
				
				//GFHTMLArea(book_gump, 300, 15, 100, 18, rune_entry.name);
				GFTextCrop(book_gump, 297, 31, 115, 17, 995, rune_entry.name);
				GFHTMLArea(book_gump, 300, 68, 120,  130, cstr(rune_entry.description), 0, 1);

			endif
		else
			GenerateEmptySide(book_gump, 2, pOX, pOY, i);
		endif

                rune_pos := rune_pos + 1;
		pOY := pOY + 15;
		if( pOY > 165 )
			pOY := 65;
			pOX := 305;
		endif

		SleepMS(2);
	endfor

//	GFOptimizeGump(book_gump);

	return book_gump;
endfunction


function GenerateEmptySide(byref book_gump, side, pOX, pOY, page_num)

	if( side == 1)
		// This puts the rune in page 1's list.
		GFPage(book_gump, 1);
		GFTextCrop(book_gump, pOX,  pOY, 115, 17, 10, "");
		GFPage(book_gump, page_num);
		GFTextCrop(book_gump, 145, 60, 115, 17, 10, "");
	else
		// This puts the rune in page 1's list.
		GFPage(book_gump, 1);
		GFTextCrop(book_gump, pOX,  pOY, 115, 17, 10, "");
		GFPage(book_gump, page_num);
		GFTextCrop(book_gump, 305, 60, 115, 17, 10, "");
	endif

endfunction
