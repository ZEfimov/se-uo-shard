/////////////////////////////////////////////
//
// combathook.src
//
// Combat System Hooks
//
// Created: 2/26/2004 1:13AM
// Updated: 06/03/2007 1:13AM
//
// Responsavel por:
//
//
////////////////////////////////////////////

use uo;
use cfgfile;

include ":attributes:attributes";
include ":combat:armorZones";
include ":combat:combat";
include "include/packets";
include "include/facings";
include "include/say";
include "include/dungeons";
include "include/damage";
include "include/utils";
include ":timedscripts:timedScripts";
include ":combat:settings";
include ":fls_core:fls_characters";

var item_cff  := ReadConfigFile(":*:itemdesc");

//Global because they're important, and it keeps the function
//prototypes shorter and easier to read.
var wpn_a_elem;
var weapon;

function CalculateRawDamage(attacker)
	if (attacker.npctemplate)
		var dmg       := wpn_a_elem.dicedmg;
      if (GetObjProperty(attacker, "dicedmg"))
         dmg := GetObjProperty(attacker, "dicedmg");
      endif
		var attribute := wpn_a_elem.Attribute;
		return ( RandomDiceRoll(dmg) + AP_GetStat(attacker, attribute, RETURN_BONUS) );
	else
		var weaponcfg  := ReadConfigFile(":*:itemdesc");
		var weaponelem := FindConfigElem(weaponcfg, weapon.objtype);
		var attribute := SelectAttribute(attacker);
		var dmg;
		if ( GetObjProperty(attacker, "metamorfose") != error)
			var dmg       := GetObjProperty(attacker, "dicedmg");
			var attribute := GetObjProperty(attacker, "attrdmg");
			dmg := RandomDiceRoll( dmg ) + AP_GetStat(attacker, attribute, RETURN_BONUS);
		else
			dmg :=  RandomDiceRoll(cstr(weaponelem.Damage)) + AP_GetStat(attacker, attribute, RETURN_BONUS) + GetAttackerDMGBonus(attacker);
		endif
		
		return ( dmg + weapon.dmg_mod );
	endif
endfunction

program Attack(params)
   var attacker := params[1];
   var defender := params[2];
	weapon := attacker.weapon;

	if ( attacker == defender )
		ApplyRawDamage(attacker, 5000);
		return 1;
   elseif (attacker.my_template() == "orb")
      return 1;
	elseif ( !CheckLineOfSight(attacker, defender) )
		return 1;
	elseif ( GetObjProperty(attacker, "#Casting") )
		return 1;
	endif

	if (attacker.acctname)
		if (!attacker.warmode)
			if(GetObjProperty(attacker, "#attackmsg") <= polcore().systime)
				SendSysMessageEx(attacker, "Você precisa estar em modo de combate para ameaçar alguém.", SSM_FAIL);
				SetObjProperty(attacker, "#attackmsg", polcore().systime+15);
			endif
			return 1;
		endif
	endif

	wpn_a_elem := GetItemCFGInfo(attacker, weapon);

	if ( attacker.frozen )
		SendSysMessage(attacker, "Você não consegue atacar.");
		return 1;
	elseif ( (attacker.concealed) && (attacker.cmdlevel == 0) )
		attacker.concealed := 0;
	elseif ( !DistanceChecks(attacker, defender) )
		return 1;
	elseif ( !FacingChecks(attacker, defender) )
		return 1;
	elseif ( !AmmoCheck(attacker, defender) )
		return 1;
   elseif ( attacker.hidden && attacker.npctemplate)
      attacker.hidden := 0;
	endif

	var attack_chance := GetAttackerChance(attacker, defender);

	var armor := CS_GetEquipmentInArmorZone(defender, CS_GetRandomArmorZone());
	armor     := CS_SelectArmored(armor);

	//Only calculate defender CA if fail/success is not sure
	var defender_CA   := 0;
	if (GetObjProperty(attacker, "#attackfail") == 1)
		EraseObjProperty(attacker, "#attackfail");
		defender_CA := 100;
	elseif (GetObjProperty(defender, "#defensefail") == 1)
		EraseObjProperty(defender, "#defensefail");
	else
		defender_CA := GetDefenderCA(defender, armor);
	endif

	//Arrow repulse magic
	if (GetObjProperty(defender, "#arrowrepulse") == 1 && weapon.isBow())
		defender_CA := 100;
	endif

	PlayAttackAnimation(attacker, wpn_a_elem);

   if (wpn_a_elem.WeaponType)
      attacker.SetAchievement(wpn_a_elem.WeaponType, 1);
   endif

	//ACERTOU
	if ( attack_chance > defender_CA )
		// if ( TemHabilidade(attacker, "golpedesleal") && IsBehind(attacker, defender.x, defender.y) )
		// 	if (RandomInt(10) < 3)
		// 		TS_StartTimer(defender, "paralysis", 2);
		// 	endif
		// endif
		WearDownWeapon(attacker);
		PlayHitSounds(attacker, defender);
		var dmg := CalculateRawDamage(attacker);
		ExpGain(attacker, defender_CA, attack_chance);
      if (attacker.master)
         attacker.SetExp(2);
      endif

		if (!defender.npctemplate && defender.shield)
			defender.SetAchievement("shield", 1);
		endif

	

		Run_Script_To_Completion(":combat:mainHitScript", array{attacker, defender, weapon, armor, dmg, dmg, wpn_a_elem });

	else //ERROU O ATAQUE
		if ( weapon.isBow() && !attacker.npctemplate )
			ArrowRecovery(defender);
		endif

		EraseObjProperty(attacker, "movement");

      if (!defender.npctemplate && defender.shield)
         WearDownArmor(defender, defender.shield);
      elseif (!defender.npctemplate && armor)
		   WearDownArmor(defender, armor);
      endif

		var armor_elem := GetItemCFGInfo(defender, armor);
		// Com armadura leve tem 40% de chance de dar miss
		if ((!armor_elem.ArmorDexLimit && RandomInt(100) <= 20) || RandomInt(100) <= 20)
			PlayMissSound(attacker);
		else
			PlayHitSounds(attacker);
			WearDownWeapon(attacker);
		endif
	endif

	return 1;
endprogram

// Rola o dado de ataque
function GetAttackerChance(attacker, defender)
	var dice_gain := 0;
	if ( !attacker.npctemplate )
		if ( GetEquipmentByLayer(attacker, LAYER_MOUNT))
			dice_gain -= -1;
		endif
	endif

	if (GetObjProperty(attacker, "#attackbonus" ) || GetObjProperty(attacker, "hitbonus") )
		dice_gain += 1;
	endif

   if (GetObjProperty(attacker, "#attack_disadvantage") || GetObjProperty(attacker, "#blinded") || attacker.paralyzed)
		dice_gain -= 1;
   endif

	if (!IsFacing(defender, attacker.x, attacker.y))
      if (!HaveFeat(defender, "Reflexos Rápidos"))
		   dice_gain += 1;
      endif
		if (!defender.npctemplate)
			defender.SetAchievement("backstabed", 1);
		endif

		if (!attacker.npctemplate)
			attacker.SetAchievement("backstab", 1);
		endif
	endif

   dice_gain += GetAttackerFeatPenalty(attacker, defender);

	var attribute := "Strength";
	var bonus := 0;
	if (!attacker.npctemplate)
		// Verifica se arma tem atributo
		attribute := SelectAttribute(attacker);
		// Checa Pericia
		if (HaveSkill(attacker, attribute))
			bonus := cint(getProficiencyBonus(attacker));
		endif
	else
		// Pega atributo principal do npc
		if (wpn_a_elem.Attribute)
			attribute := wpn_a_elem.Attribute;
		endif
		bonus := cint(wpn_a_elem.hitbonus);
	endif

   bonus += GetAttackerFeatBonus(attacker, 0);
	
	var dice := rollAttrDice(attacker, attribute, dice_gain) + bonus;
	return dice;
endfunction

function SelectAttribute(attacker)
	var attribute := STRENGTH;
	if (weapon.Attribute)
		attribute := weapon.Attribute;
		// Escolhe maior atributo para versatilidade
		if (attribute == "Versatil")
			var dex := AP_GetTrueStat(attacker, DEXTERITY);
			var str := AP_GetTrueStat(attacker, STRENGTH);
			if (str > dex)
				attribute := DEXTERITY;
			else
				attribute := STRENGTH;
			endif
		endif
	endif

	return attribute;
endfunction

function GetDefenderCA(defender, armor)
	var CA := 5;
	if ( !defender.npctemplate )
		if (armor)
			CA := armor.ar_base; //se é armadura pesada, n tem dex

			var armor_elem := GetItemCFGInfo(defender, armor);
			if (armor_elem.pericia == ARMADURA_LEVE)
            defender.SetAchievement("lightarmor", 1);
				CA += GetBonusAttr(AP_GetTrueStat(defender, "Dexterity"));
			elseif (armor_elem.pericia == ARMADURA_MEDIA)
            defender.SetAchievement("mediumarmor", 1);
				var mod := GetBonusAttr(AP_GetTrueStat(defender, "Dexterity"));
				if (mod > 2) //max de mod é 2 pra média
					mod := 2;
				endif

				CA += mod;
         elseif (armor_elem.pericia == ARMADURA_PESADA)
            defender.SetAchievement("heavyarmor", 1);
			endif
		else
			// Se n tem armadura, usa defesa
			CA := 10 + GetBonusAttr(AP_GetTrueStat(defender, "Dexterity"));
		endif

		if (defender.shield)
			CA += defender.shield.ar_base;
		endif

      var wpn_elem := GetItemCFGInfo(defender, defender.weapon);
      if (defender.weapon.WeaponType == "dualsword" && HaveFeat(defender, "Defesa Perfeita"))
         CA += 1;
      endif
	else
		var npcelem := NPC_GetNPCConfig(defender.npctemplate);
		CA := cint(npcelem.AR);
	endif

	var ca_bonus := cint(GetObjProperty(defender, "bonus_ca"));
	if (ca_bonus)
		CA += ca_bonus;
	endif

	//não ta em warmode, 95% de chance
	if (defender.acctname && !defender.warmode)
		CA := 5;
	endif

	return CA;
endfunction

function WearDownArmor(defender, armor)
	if ( armor )
		var armr_elem := CS_GetSettingsCfgElem("Armor");
		var wearchance := armr_elem.WearChance;
		// if ( TemHabilidade(defender, "Conservar Equipamento"))
		// 	wearchance := wearchance/2;
		// 	if (wearchance < 1)
		// 		wearchance := 1;
		// 	endif
		// endif

		if ( RandomDiceRoll("1d100") <= wearchance )
			SendSysMessage(defender, "Seu equipamento foi danificado.");
			var armorhp := armor.hp;
			armorhp := armorhp - Cint(armr_elem.WearRate);
			if ( armorhp <= 0 )
				armor.hp := 0;
				SendSysMessage(defender, armor.desc+" foi destruida.");
				SetObjProperty(armor, "broken", 1);
				SetObjProperty(armor, "realdesc", armor.desc);
				SetName(armor, armor.desc+" [danificado]");
				MoveItemToContainer(armor, defender.backpack);
			elseif ( armor.hp > armor.maxhp )
				armor.hp := armor.maxhp;
			else
				armor.hp := armorhp;
			endif
		endif
	endif
	
	return 1;
endfunction

function WearDownWeapon(attacker)
	if ( weapon.IsA(POLCLASS_WEAPON) && !attacker.npctemplate)
		if ( weapon.objtype == 0x1F020)
			return 1;
		endif
		var wpn_elem := CS_GetSettingsCfgElem("Weapons");
		var wearchance := CInt(wpn_elem.WearChance);
		var roll := RandomDiceRoll("1d100");
		if ( roll <= wearchance )
			var weaponhp := weapon.hp - 1;				
			if ( weaponhp <= 0 )
				weapon.hp := 0;
				SendSysMessage(attacker, weapon.desc+" quebrou.");
				MoveObjectToLocation(weapon, 1, 1, 1, attacker.realm, MOVEOBJECT_FORCELOCATION);
				SetObjProperty(weapon, "broken", 1);
				SetObjProperty(weapon, "realdesc", weapon.desc);
				SetName(weapon, weapon.desc+" [danificado]");
				MoveItemToContainer(weapon, attacker.backpack);
			elseif ( weapon.hp > weapon.maxhp )
				weapon.hp := weapon.maxhp;
			else
				weapon.hp := weaponhp;
			endif
		endif
		return 1;
	endif

	return 0;
endfunction

// Checa por munição ou faz efeito do npc arqueiro
function AmmoCheck(attacker, defender)
   var cfgfile := NPC_GetNPCConfig(attacker.npctemplate);
	if (weapon.isMagicWeapon())
      attacker.SetAchievement("magicweapon", 1);
		PlayMovingEffectXYZHued(attacker, defender, wpn_a_elem.ProjectileAnim, 5, 10, 0, cint(wpn_a_elem.ProjectileColor));
		return 1;
	elseif ( !weapon.isBow() && !cfgfile.Ranged)
		return 1;
	endif

	if(attacker.npctemplate)
      if (wpn_a_elem.ProjectileAnim)
		   PlayMovingEffectXYZHued(attacker, defender, wpn_a_elem.ProjectileAnim, 10, 10, 0, cint(wpn_a_elem.ProjectileColor));
      else
		   PlayMovingEffectXYZHued(attacker, defender, cint(cfgfile.ProjectileAnim), 10, 10, 0, cint(cfgfile.ProjectileColor));
      endif
		return 1;
	endif

	var aljava := GetEquipmentByLayer(attacker, LAYER_CAPE);
	var ammo   := GetObjProperty(weapon, "ammo");
	if (!ammo)
		SendSysMessageEX(attacker, "Você não definiu o tipo de flecha que vai usar. [clique 2x no arco e na flecha]", SSM_FAIL);
		return 0;
	endif
	if ( ConsumeSubstance( aljava, ammo, 1 ) )
		var cfg  := ReadConfigFile(":woodworking:itemdesc");
		var elem := FindConfigElem(cfg, ammo);
		var ammo_color := elem.color;
		PlayMovingEffectXYZHued(attacker, defender, wpn_a_elem.ProjectileAnim, 10, 10, 0, ammo_color);
		return 1;
	else
		SendSysMessageEX(attacker, "Sua flecha acabou ou esta fora da aljava.", SSM_FAIL);
		return 0;
	endif

endfunction

// Cria as munição no chão
function ArrowRecovery(defender)
	var chance := 15;
	if ( RandomDiceRoll("1d100") <= chance )
		var ammo := GetObjProperty(weapon, "ammo");
		var point := RandomPlace(defender, 1);
		CreateItemAtLocation(point.x, point.y, defender.z, ammo, 1, defender.realm);
	endif
endfunction

// Checa direção q ta olhando
function FacingChecks(attacker, defender)
	var retval := 1;
	if ( !IsFacing(attacker, defender.x, defender.y) )
		if ( attacker.npctemplate )
			TurnObjectToward(attacker, defender.x, defender.y);
		else
			if ( IsBehind(attacker, defender.x, defender.y) )
				SendSysMessageEx(attacker, "Você esta de costas para o inimigo!", SSM_FAIL);
				retval := 0;
			endif
		endif
	elseif ( !IsFacing(defender, attacker.x, attacker.y) )
		if ( defender.npctemplate )
			TurnObjectToward(defender, attacker.x, attacker.y);
		endif
	endif

	return retval;
endfunction

function GetAttackerFeatPenalty(attacker, defender)
   var bonus := 0;
   if (defender.acctname && attacker.npctemplate) //mob vs player
      var mobiles_near := ListMobilesNearLocationEx(defender.x, defender.y, defender.z, 2, LISTEX_FLAG_NORMAL|LISTEX_FLAG_PLAYERS_ONLY);
      foreach mob in mobiles_near
         if (HaveFeat(mob, "Presença Imponente"))
            bonus -= 1;
            break;
         endif
      endforeach
   endif

   return bonus;
endfunction

function GetAttackerDMGBonus(attacker)
   var bonus := 0;

   // if (wpn_a_elem.WeaponType == "sword" && HaveFeat(attacker, "Mestre das Lâminas"))
   //    bonus += 1;
   // elseif (wpn_a_elem.WeaponType == "arco" && HaveFeat(attacker, "Arqueiro Experiente"))
   //    bonus += 1;
   // elseif (wpn_a_elem.WeaponType == "arco" && HaveFeat(attacker, "Arqueiro Experiente"))
   //    bonus += 1;
   // elseif (wpn_a_elem.WeaponType == "arco" && HaveFeat(attacker, "Arqueiro Experiente"))
   //    bonus += 1;
   // elseif (wpn_a_elem.WeaponType == "arco" && HaveFeat(attacker, "Arqueiro Experiente"))
   //    bonus += 1;
   // endif
      
   return bonus;
endfunction

function GetAttackerFeatBonus(attacker, roll)
   var bonus := 0;

   if (wpn_a_elem.WeaponType == "sword" && HaveFeat(attacker, "Mestre das Lâminas"))
      bonus += 1;
   elseif (wpn_a_elem.WeaponType == "bow" && HaveFeat(attacker, "Arqueiro Experiente"))
      bonus += 1;
   elseif (wpn_a_elem.WeaponType == "dagger" && HaveFeat(attacker, "Golpe Baixo"))
      bonus += 1;
   elseif (wpn_a_elem.WeaponType == "spear" && HaveFeat(attacker, "Lanceiro"))
      bonus += 1;
   elseif (wpn_a_elem.WeaponType == "arco" && HaveFeat(attacker, "Arqueiro Experiente"))
      bonus += 1;
   endif
      
   return bonus;
endfunction