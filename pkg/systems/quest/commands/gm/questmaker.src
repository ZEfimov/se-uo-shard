// Created 11/6/18 4:42:13 AM, with Gump Studio.
// Exported with POLGumpExporter ver 1.1 for gump pkg

use uo;
use os;
use cfgfile;

include ":gumps:gumps";
include ":yggdrasil:spawnSpot";
include ":quest:quest";
include ":gumps:requestgump";
include ":gumps:gumps_ex";
include ":gumps:yesno";
include ":tn:tngumps";
include "include/say";
include "include/utils";
include ":unicos:item_template";

var selected_quest := 0;
var quest_list;
var quest;
var quest_names := array{};
var qualities := array{"Comum", "Bom", "Raro", "Exótico"};

var quest_title;
var quest_desc := array{};
//Main Menu
const GF_ADD_BTN        := 900;
const GF_DEL_BTN        := 901;
const GF_SELECTELEM_BTN := 100;

const GF_QUEST_ACTIVE   := 800;
const GF_QUEST_CATEGORY := 801;
const GF_QUEST_LEVEL    := 802;
const GF_ADD_TOPLAYER_QUEST := 805;
const GF_REWARD_ADD     := 803;
const GF_REWARD_EDIT    := 840;
const GF_CONDITION_ADD  := 804;
const GF_CONDITION_EDIT := 850;
const GF_EXTRA_ADD      := 806;
const GF_QUEST_DIFFICULTY := 807;
const GF_EXTRA_EDIT     := 860;

function GumpQuestInfo(byref gump, who)
   quest := GetQuestData(selected_quest);
	GFResizePic(gump, 254, 13, 311, 566, 596);
	GFGumpPic(gump, 605, 37, 59, 0);
	GFGumpPic(gump, 456, 36, 57, 0);
	GFTextLine(gump, 494, 34, 1995, "Editor de Quests");

	GFTextLine(gump, 280, 63, 1152, "Título Quest:");
	GFResizePic(gump, 365, 61, 9350, 209, 22);
	quest_title := GFTextEntry(gump, 370, 60, 200, 20, 0, "{}".format(quest.title), 0);

	GFTextLine(gump, 281, 89, 1152, "Quest Ativa:");
   if (quest.active)
	   GFAddButton(gump, 364, 92, 2361, 2361, GF_CLOSE_BTN, GF_QUEST_ACTIVE);
   else
	   GFAddButton(gump, 364, 92, 2360, 2360, GF_CLOSE_BTN, GF_QUEST_ACTIVE);
   endif

   var pos_y := 0;
	GFTextLine(gump, 585, 63, 1152, "Categoria");
	GFResizePic(gump, 656, 63, 9350, 140, 44);
	GFAddButton(gump, 660, 70, 2103, 2103, GF_CLOSE_BTN, GF_QUEST_CATEGORY);
   GFHTMLArea(gump, 679, 63, 150, 44, "{}".format(", ".join(quest.category)));

   GFTextLine(gump, 430-45, 89, 1152, "Dificuldade");
	GFResizePic(gump, 496-45, 89, 9350, 40, 22);
	GFAddButton(gump, 500-45, 94, 2103, 2103, GF_CLOSE_BTN, GF_QUEST_DIFFICULTY);
	GFTextLine(gump, 519-45, 89, 1152, "{}".format(quest.difficulty));

   GFTextLine(gump, 540-45, 89, 1152, "Level");
	GFResizePic(gump, 576-45, 89, 9350, 40, 22);
	GFAddButton(gump, 580-45, 94, 2103, 2103, GF_CLOSE_BTN, GF_QUEST_LEVEL);
	GFTextLine(gump, 599-45, 89, 1152, "{}".format(quest.level));

	GFTextLine(gump, 617, 116, 1152, "Recompensas");
	GFGumpPicTiled(gump, 614, 127, 156, 21, 58);
	GFGumpPic(gump, 769, 127, 59, 0);
   pos_y := 0;
   foreach item in (quest.rewards)
	   GFAddButton(gump, 610, 146+pos_y, 2103, 2103, GF_CLOSE_BTN, GF_REWARD_EDIT+_item_iter);
      var desc := item.type;
      if (item.item) desc += " [{}]".format(item.item.desc); endif
      // if (item.spawngroup) desc += " [{}]".format(item.spawngroup); endif
      if (item.classe) desc += " [{}]".format(item.classe); endif
      if (item.item.dmg_mod) desc += " [P: {}]".format(item.item.dmg_mod); endif
	   GFTextLine(gump, 625, 142+pos_y, 1152, "{}".format(desc));
      pos_y += 18;
      sleepms(2);
   endforeach
   if (quest.rewards.size() < 10)
      GFAddButton(gump, 777, 156+pos_y, 2361, 2361, GF_CLOSE_BTN, GF_REWARD_ADD);
      GFTextLine(gump, 711, 151+pos_y, 1152, "Adicionar");
   endif

	GFTextLine(gump, 282, 116, 1152, "Condições de Sucesso");
	GFGumpPic(gump, 532, 127, 59, 0);
	GFGumpPicTiled(gump, 279, 127, 257, 21, 58);
   pos_y := 0;
   foreach item in (quest.conditions)
	   GFAddButton(gump, 279, 146+pos_y, 2103, 2103, GF_CLOSE_BTN, GF_CONDITION_EDIT+_item_iter);
      var desc := item.type;
      if (item.template) desc += " [{}]".format(item.template); endif
      // if (item.spawngroup) desc += " [{}]".format(item.spawngroup); endif
      if (item.qty) desc += " [{}]".format(item.qty); endif
	   GFTextLine(gump, 295, 142+pos_y, 1152, "{}".format(desc));
      var tooltip := "<center>";
      if (item.spawngroup) tooltip += "Spawngroup: {}<br>".format(item.spawngroup); endif
      if (item.party) tooltip += "Party Contabliza<br>"; endif
      if (item.boss) tooltip += "Apenas Boss<br>"; endif
      if (item.customname) tooltip += "Custom Name: {}<br>".format(item.customname); endif
      if (item.item_serial) tooltip += "Serial do item: {}<br>Use .goserial {} para ir até ele.".format(item.item_serial, item.item_serial); endif
      if (item.quality) tooltip += "Qualidade: {}<br>".format(qualities[item.quality]); endif
      if (item.spawnpoint) 
         var spawnpoint := SystemFindObjectBySerial(item.spawnpoint);
         tooltip += "Spawnpoint: {}<br>".format(spawnpoint.desc);
         tooltip += "Spawnpoint Loc: {} {} {}<br>".format(spawnpoint.x, spawnpoint.y, spawnpoint.z);
      endif
      if (item.item_specify) tooltip += "Item: {}<br>".format(item.item_specify.desc); endif
      if (item.item_objtype) tooltip += "Objtype: {}<br>".format(item.item_objtype); endif
      if (item.color) tooltip += "Color: {}<br>".format(item.color); endif
      GFTooltipText(gump, tooltip);

      pos_y += 18;
      sleepms(2);
   endforeach

   if (quest.conditions.size() < 10)
      GFAddButton(gump, 546, 155+pos_y, 2361, 2361, GF_CLOSE_BTN, GF_CONDITION_ADD);
      GFTextLine(gump, 480, 150+pos_y, 1152, "Adicionar");
   endif

	GFGumpPicTiled(gump, 578, 154, 1, 258, 2701);
	GFGumpPic(gump, 766, 277, 59, 0);
	GFGumpPicTiled(gump, 611, 277, 156, 21, 58);

	GFTextLine(gump, 614, 266, 1152, "Configurações Extras");
   if (quest.extras.size() < 10)
      GFAddButton(gump, 782, 306, 2361, 2361, GF_CLOSE_BTN, GF_EXTRA_ADD);
      GFTextLine(gump, 716, 301, 1152, "Adicionar");
   endif

	GFGumpPicTiled(gump, 578, 154+100, 1, 258, 2701);
	GFGumpPic(gump, 766, 277+100, 59, 0);
	GFGumpPicTiled(gump, 611, 277+100, 156, 21, 58);

	GFTextLine(gump, 614, 266+100, 1152, "Outros");
   GFAddButton(gump, 782, 306+100, 2103, 2103, GF_CLOSE_BTN, GF_ADD_TOPLAYER_QUEST);
   GFTextLine(gump, 690, 301+100, 1152, "Receber Quest");

	GFTextLine(gump, 280, 458, 1152, "Descrição da Quest (Use <br> para quebrar linha, <i> para itálico e <b> para negrito)");
	GFResizePic(gump, 277, 478, 9350, 518, 109);

   var texts := GFWordWrap(quest.description, 535);
   var i := 1;
   for (i; i<=5; i+=1)
      var text := _ifElse(texts[i], texts[i], "");
	   quest_desc[i] := GFTextEntry(gump, 279, 481+((i-1)*18), 512, 20, 0, "{}".format(text), 0);
      sleepms(2);
   endfor
endfunction

function GumpQuestList(who)
	var gump := GFCreateGump();
   GFSetID(gump, 0x7898);
	GFResizePic(gump, 5, 12, 311, 242, 600);
	GFTextLine(gump, 77, 30, 1995, "Criação de Quests");
	GFGumpPic(gump, 203, 33, 59, 0);
	GFGumpPic(gump, 36, 32, 57, 0);

   quest_list := DFGetElemNames(LoadQuestData());
   quest_names := array{};
   var pos_y := 0;
   foreach q in quest_list
      var quest :=  GetQuestData(q);
      quest_names.append(quest.title);
      if (quest.id == cstr(selected_quest))
	      GFGumpPic(gump, 24, 54+pos_y, 4006, 0);
      else
         GFAddButton(gump, 24, 54+pos_y, 4005, 4007, GF_CLOSE_BTN, GF_SELECTELEM_BTN+cint(q));
      endif
      GFTextLine(gump, 57, 55+pos_y, 1152, quest.title);
      pos_y += 24;
      sleepms(2);
   endforeach

	GFAddButton(gump, 213, 80-20+pos_y, 2361, 2361, GF_CLOSE_BTN, GF_ADD_BTN);
	GFTextLine(gump, 150, 74-20+pos_y, 1152, "Adicionar");
   if (selected_quest)
      GFAddButton(gump, 119, 80-20+pos_y, 2360, 2360, GF_CLOSE_BTN, GF_DEL_BTN);
      GFTextLine(gump, 59, 74-20+pos_y, 1152, "Remover");

      GumpQuestInfo(gump, who);
   endif

   return GFSendGump(who, gump);
endfunction

program gump_gump(who)
   while(who.connected)
      sleepms(2);
      var res := GumpQuestList(who);
      
      var update_quest := struct{};
      if (selected_quest)
         update_quest["title"] := GFExtractData(res, quest_title);
         update_quest["description"]  := array{};
         foreach i in (quest_desc)
            var output := GFExtractData(res, i);
            if (output && output != " " && output != "") update_quest.description.append(output); endif
            sleepms(2);
         endforeach
         update_quest.description := " ".join(update_quest.description);
         SetQuestData(selected_quest, update_quest);
      endif

      if (res[0] <= 5 || !res[0])
         break;
      elseif (res[0] >= GF_CONDITION_EDIT && res[0] <= GF_CONDITION_EDIT+10)
         var pos := res[0] - GF_CONDITION_EDIT;
         var opts := array{"Editar", "Remover"};
         if (quest.conditions[pos].item_objtype) opts.append("Criar Item"); endif
         if (quest.conditions[pos].item_serial) opts.append("Ir até Item"); endif
         if (quest.conditions[pos].spawnpoint) opts.append("Ir até spawnpoint"); endif
         var answer := QuestionsGump(who, array{ struct{ title := "O que deseja fazer?", radio := opts, marked := 1 }});
         if (!answer) continue; endif
         if (answer[1] == "Editar")
            var res := QuestConditions(who, quest.conditions[pos]);
            if (res) 
               quest.conditions[pos] := res; 
               update_quest.conditions  := quest.conditions;
            endif
         elseif (answer[1] == "Remover")
            quest.conditions.Erase(pos);
            update_quest.conditions  := quest.conditions;
         elseif (answer[1] == "Ir até Item" || answer[1] == "Ir até spawnpoint")
            var obj := SystemFindObjectBySerial(_ifOr(quest.conditions[pos].item_serial, quest.conditions[pos].spawnpoint));
            MoveObjectToLocation(who, obj.x, obj.y, obj.z, obj.realm, MOVEOBJECT_FORCELOCATION);
         elseif (answer[1] == "Criar Item")
            _CreateItemInBackpack(who, quest.conditions[pos].item_objtype, 1);
         elseif (answer[1] == opts.size())
            continue;
         endif

         SetQuestData(selected_quest, update_quest);
      elseif (res[0] >= GF_REWARD_EDIT && res[0] <= GF_REWARD_EDIT+10)
         var answer := RadioGump(who, 180, 0, "O que deseja fazer?:", array{"Editar", "Remover", "Cancelar"}, 3);
         var pos := res[0] - GF_REWARD_EDIT;
         if (answer == 1)
            var res := QuestRewards(who, quest.rewards[pos]);
            if (res) 
               quest.rewards[pos] := res; 
               update_quest.rewards  := quest.rewards;
            endif
         elseif (answer == 2)
            quest.rewards.Erase(pos);
            update_quest.rewards  := quest.rewards;
         else
            continue;
         endif

         SetQuestData(selected_quest, update_quest);
      elseif (res[0] >= GF_SELECTELEM_BTN && res[0] <= GF_SELECTELEM_BTN+150)
         selected_quest := res[0]-GF_SELECTELEM_BTN;
      else
         case (res[0])
            GF_ADD_BTN:
               var id := cint(quest_list[quest_list.size()]) +1 ;
               if (!YesNo(who, "Escolha uma opção:", "Copiar Quest", "Nova Quest"))
                  var quest_name := RequestGump(who, "Título da Quest", "", "", CANCEL_BTN_ON);
                  SetQuestData(id, struct{ title := quest_name});
               else
                  var res := QuestionsGump(who, array{ struct{ text := "Escolha quest que irá copiar", radio := quest_names }});
                  if (!res) break; endif
                  if (!res[1]) break; endif
                  var quest := GetQuestData(quest_list[res[1] in quest_names]);
                  var quest_name := RequestGump(who, "Título da Quest", "", "", CANCEL_BTN_ON);
                  quest.title := quest_name;
                  SetQuestData(id, quest);
               endif
               selected_quest := id;
               update_quest := struct{};
               break;
            GF_DEL_BTN:
               RemoveQuestData(selected_quest);
               selected_quest := 0;
               break;
            GF_QUEST_DIFFICULTY:
               var opts := array{"Fácil", "Díficil"};
               update_quest["difficulty"] := RadioGump(who, 200, 0, "Escolha o level de dificuldade:", opts, 1, quest.level in opts);
               break;
            GF_QUEST_LEVEL:
               var opts := array{"1", "2", "3", "4"};
               update_quest["level"] := RadioGump(who, 150, 0, "Escolha o level da classe:", opts, 0, quest.level in opts);
               break;
            GF_QUEST_CATEGORY:
               var classCfg := ReadConfigFile(":charactercreation:config/classes");
               var opts := GetConfigStringKeys(classCfg);
               var marked := array{};
               foreach item in opts
                  marked[_item_iter] := item in quest.category;
               endforeach

               update_quest["category"] := CheckBoxGump(who, 200, 0, "Escolha a Categoria:", opts, marked);
               break;
            GF_QUEST_ACTIVE:
               update_quest["active"] := !quest.active;
               break;
            GF_CONDITION_ADD:
               var new_condition := QuestConditions(who);
               if (!new_condition) break; endif
               quest.conditions.append(new_condition);
               update_quest["conditions"] := quest.conditions;
               break;
            GF_REWARD_ADD:
               var new_reward := QuestRewards(who);
               if (!new_reward) break; endif
               quest.rewards.append(new_reward);
               update_quest["rewards"] := quest.rewards;
               break;
            GF_EXTRA_ADD:
               var new_extra := QuestExtras(who);
               if (!new_extra) break; endif
               quest.extras.append(new_extra);
               update_quest["extras"] := quest.extras;
               break;
            GF_ADD_TOPLAYER_QUEST:
               SendSysMessageEx(who, "Dar essa quest para quem ?", SSM_REQUEST);
               var targ := Target(who);
               if (!targ) break; endif
               var new_quest := quest;
               if (quest.category.size() > 1)
                  var q := RadioGump(who, 300, 0, "Qual a classe?", quest.category, 0);
                  new_quest.category := q in quest.category;
               endif
               
               GiveQuest(targ, new_quest, 0, 1);
               SendSysMessageEx(who, "Quest adicionada.", SSM_REQUEST);
         endcase
         
         if (selected_quest)
            SetQuestData(selected_quest, update_quest);
         endif
      endif

   endwhile
endprogram

function QuestConditions(who, new_condition := struct{})
   var opts := array{
      "Matar Monstro",
      "Usar Item",
      "Craftar Item",
      "Coletar Item",
      "Ir até Local",
      "Domesticar Animal",
      "Desarmar Armadilha",
      "Arrombar Bau/Porta",
      "Cancelar"
   };

   if (!new_condition.type)
      new_condition.type := RadioGump(who, 300, 0, "Qual condição quer configurar?", opts, 0);
   endif

   case (new_condition.type)
      "Cancelar": return 0;
      "Matar Monstro":
         if (!new_condition.template)
            if (YesNo(who, "Deseja selecionar o monstro ou iniciar manualmente?", "Preencher", "Manualmente"))
               SendSysMessage(who, "Escolha o monstro a ser morto.");
               var targ := Target(who);
               if (targ && targ.isA(POLCLASS_MOBILE))
                  new_condition["template"]   := targ.npctemplate;
                  new_condition["qty"]        := 10;
                  new_condition["party"]      := 1;
                  new_condition["onlyboss"]   := isBoss(targ);
                  new_condition["color"] := targ.color;
                  new_condition["customname"] := targ.name;
               endif
            endif
         endif
         var spawnpoint := SystemFindObjectBySerial(new_condition["spawnpoint"]);
         var quest_gump := array{
            struct{ title := "Deseja selecionar um spawnpoint? (Atual é: {})".format(_ifElse(spawnpoint, spawnpoint.desc, "Nenhum")), radio := array{"Não", "Sim", "Remover spawnpoint existente" }, marked := 1 },
            struct{ title := "Entre com template do monstro", marked := _IfOr(new_condition.template, ":ghaia:") },
            struct{ title := "Quantidade de monstros que deve matar", marked := _IfOr(new_condition.qty, "10") },
            struct{ title := "Validar monstros mortos pela party?", radio := array{"Não", "Sim"}, marked := cint(new_condition.party)+1 },
            struct{ title := "Apenas monstros BOSS?", radio := array{"Não", "Sim"}, marked := cint(new_condition.onlyboss)+1 },
            struct{ title := "Cor do monstro, para mobs diferentes.", marked := _IfOr(new_condition.color, "0") },
            struct{ title := "Customizar nome do monstro? (deixe em branco se não quiser)", marked := _IfOr(new_condition.customname, "") }
         };
         var output := QuestionsGump(who, quest_gump);
         if (!output) return 0; endif

         if (!NPC_Checktemplate(output[2])) SendSysMessageEx(who, "Template {} não existe!".format(output[2]), SSM_FAIL); return 0; endif
         new_condition["template"]   := output[2];
         new_condition["qty"]        := cint(output[3]);
         new_condition["party"]      := output[4] == "Sim";
         new_condition["onlyboss"]   := output[5] == "Sim";
         new_condition["color"] := cint(output[6]);
         new_condition["customname"] := output[7];

         if (output[1] == "Sim")
            var targ := Target(who);
            if (!targ || targ.objtype != 41985) 
               SendSysMessageEx(who, "Isso não é um spawnpoint");
            else
               new_condition["spawnpoint"] := targ.serial;
            endif
         elseif (output[1] == "Remover spawnpoint existente")
            new_condition["spawnpoint"] := 0;
         endif
      "Ir até Local":
         SendSysMessage(who, "Escolha o RoleplayItem que irá disparar.");
         var targ := Target(who);
         if (!targ || !targ.isA(POLCLASS_ITEM) || Hex(targ.objtype) != 0x318E) return 0; endif
         new_condition.local := targ.serial;
      "Coletar Item":
         SendSysMessage(who, "Escolha o item que deve ser coletado.");
         var targ := Target(who);
         if (!targ || !targ.isA(POLCLASS_ITEM)) return 0; endif
         var quest_gump := array{
            struct{ title := "Quantidade que deve ser coletado?", marked := _ifOr(new_condition.qty, "10") }
         };
         var output := QuestionsGump(who, quest_gump);
         if (!output) return 0; endif
         new_condition.item_objtype := targ.objtype;
         new_condition.item_specify := CreateItemTemplate(targ);
         new_condition.qty := cint(output[1]);
         new_condition.color := cint(targ.color);
      "Craftar Item":
         if (!new_condition.item_objtype)
            var recipe_list := ReadConfigFile(":*:recipes");
            var targ := ChooseItem(who, "Escolha o item que deve ser craftado.");
            if (!targ) return 0; endif
            if (!FindConfigElem(recipe_list, cint(targ.objtype)) && !FindConfigElem(recipe_list, hex(targ.objtype)))
               SendSysMessageEx(who, "Não existe receita para este item", SSM_FAIL);
               return 0; 
            endif
            new_condition.item_objtype := targ.objtype;
         endif

         var quest_gump := array{
            struct{ title := "Quantidade que deve ser craftado?", marked := _ifOr(new_condition.qty, "10") },
            struct{ title := "Qualidade minima a ser craftado?", marked := _ifOr(new_condition.quality, 1), radio:= qualities }
         };
         var output := QuestionsGump(who, quest_gump);
         if (!output) return 0; endif

         new_condition.qty := cint(output[1]);
         new_condition.quality := cint(output[2] in qualities);
      "Domesticar Animal":
         if (!new_condition.template)
            var targ := ChooseItem(who, "Escolha o animal a ser domesticado.", POLCLASS_MOBILE);
            if (!targ) return 0; endif
            new_condition["template"]   := targ.npctemplate;
         endif
         var quest_gump := array{
            struct{ title := "Quantidade que deve ser domesticado?", marked := _ifOr(new_condition.qty, "1") }
         };
         var output := QuestionsGump(who, quest_gump);
         if (!output) return 0; endif

         new_condition.qty := cint(output[1]);
      "Usar Item":
         var item := ChooseItem(who);
         if (!item) return 0; endif

         SetObjproperty(item, "quest_item", 1);
         new_condition.item_serial := item.serial;
      "Desarmar Armadilha":
         var item := ChooseItem(who);
         if (!item || (!item.IsTrap() && GetObjProperty(item, "TrapList"))) return 0; endif

         new_condition.item_serial := item.serial;
      "Arrombar Bau/Porta":
         var item := ChooseItem(who);
         if (!item || (!item.isA(POLCLASS_DOOR) && !item.isA(POLCLASS_CONTAINER))) return 0; endif

         new_condition.item_serial := item.serial;
   endcase

   return new_condition;
endfunction

function ChooseItem(who, text := "Escolha o item que deve ser usado.", pol_type := POLCLASS_ITEM)
   SendSysMessage(who, text);
   var targ := Target(who);
   if (!targ || !targ.isA(pol_type)) return 0; endif

   return targ;
endfunction

function QuestRewards(who, new_reward := struct{})
   var opts := array{
      "Experiência",
      "Item",
      "Cancelar"
   };

   if (!new_reward.type)
      new_reward.type := RadioGump(who, 350, 0, "Qual tipo de recompensa deseja atribuir?", opts, 0);
   endif

   case (new_reward.type)
      "Cancelar": return 0;
      "Experiência":
         var classCfg := ReadConfigFile(":charactercreation:config/classes");
         var opts := GetConfigStringKeys(classCfg);
         opts.append("Classe Da Quest");
         opts.append("Personagem");
         new_reward.classe := _ifOr(new_reward.classe, "Classe da Quest");
         new_reward.classe := RadioGump(who, 200, 0, "Escolha qual Classe:", opts, 0, new_reward.classe in opts);
      "Item":
         SendSysMessage(who, "Escolha o item de recompensa.");
         var targ := Target(who);
         if (!targ || !targ.isA(POLCLASS_ITEM)) return 0; endif
         new_reward.item := CreateItemTemplate(targ);			
         return 0;
   endcase

   return new_reward;
endfunction

function QuestExtras(who)
   var new_extra := struct{};
   var opts := array{
      // "Experiência",
      "Requerer Habilidade",
      "Cancelar"
   };

   var type := RadioGump(who, 200, 0, "Qual tipo de extra deseja configurar?", opts, 0);
   new_extra["type"] := type;

   case (type)
      "Cancelar": return 0;
      "Experiência":
      "Item":
         SendSysMessageEx(who, "Extra não scriptado, srry!", SSM_FAIL);
         return 0;
   endcase
   return new_extra;
endfunction