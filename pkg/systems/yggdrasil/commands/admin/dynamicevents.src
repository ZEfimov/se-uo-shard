
use uo;
use datafile;
use basic;

include ":yggdrasil:spawnGroup";
include ":yggdrasil:dynamicevents";
// include ":ghaia:ghaiaUtil";
include ":gumps:requestgump";
include ":gumps:gumps_ex";
include ":gumps:yesno";
include ":tn:tngumps";
include "include/say";
include ":unicos:item_template";

//Main Menu
const GF_GROUP_ACTIVE_SWITCH := 2;
const GF_ADD_BTN        := 3;
const GF_DEL_BTN        := 4;
const GF_SELECTELEM_BTN := 10;

//Moblist menu
const GF_ADDEVENT_BTN    := 101;
const GF_DELEVENT_BTN    := 102;
const GF_SELECTEVENT_BTN := 110;

//Moblist menu
const GF_ADDCONDITION_BTN    := 201;
const GF_DELCONDITION_BTN    := 202;
const GF_SELECTCONDITION_BTN := 210;

// Event/Conditiosn BTN
const GF_EVENT_UPDATE_BTN := 301;
const GF_EVENT_CHANGE_BTN := 302;
const GF_EVENT_BTN := 300;

var event_options := array{"Summon Mobs", "Create Item", "Change Environment", "Destroy Item", "Apply TimedScript"};
var condition_options := array{"Minimum Players", "Mobiles Died", "Boss Died", "Every Second", "Battle Started", "% of Chance", "Player Class", "Light near"};

//Basic
var selected_dynamicevent := ""; //Name of the Elem
var selected_event        := ""; //Name of the spawngroup
var selected_condition    := ""; //Name of the spawngroup
var config_struct;
var dynamiceventgroups;
var gumpid := 0x1F9;

program spotGroups(params)
    var who;
    if (TypeOf(params) != "Array")
        who := params;
        params := 0;
    else
        who := params[1];
        params := params[2];
    endif

    CloseGump(who, gumpid);
    if (params)
        selected_dynamicevent      := params.dynamicevent; //Name of the Elem
    endif

    var closed := 0;
    while (closed != 1)
        var gump := ConstructGump();
        var input := GFSendGump(who, gump);

        if (selected_dynamicevent)
            // var active_switch := GFExtractData(input, GF_GROUP_ACTIVE_SWITCH);
            // if (!active_switch || active_switch == error)
            //     active_switch := 0;
            // endif
            // SetSpotGroupData(selected_dynamicevent, struct{"active":=active_switch});
        endif

        if (selected_event)
            // var spawnpoint := SystemFindObjectBySerial(selected_spawnpoint);
            // var new_spawnpoint := struct{
            //     "name"       := GFExtractData(input, spawnpoint_name),
            //     "mob_number" := GFExtractData(input, spawnpoint_mobnumber),
            //     "range"      := GFExtractData(input, spawnpoint_range)
            // };
            // spawnpoint.SetProps(new_spawnpoint);
        endif

        if (selected_condition)
            // var active_switch := GFExtractData(input, GF_SPOT_ACTIVE_SWITCH);
            // if (!active_switch || active_switch == error)
            //     active_switch := 0;
            // endif
            // var spot := SystemFindObjectBySerial(selected_spot);
            // var new_spot := struct{
            //     "active" := active_switch,
            //     "name" := GFExtractData(input, spot_name),
            //     "evententry" := GFExtractData(input, spot_evententry),
            //     "timeinterval" := GFExtractData(input, spot_timeinterval)
            // };
            // spot.SetProps(new_spot);
        endif

        if ((input[0] >= 1 && input[0] < 100)
            DoDynamicEventList(who, input[0]);
        elseif ((input[0] >= 100 && input[0] < 200)
            DoEventList(who, input[0]);
        elseif ((input[0] >= 200 && input[0] < 930))
            DoConditionList(who, input[0]);
        elseif (input[0] >= 300 && input[0] < 940)
            DoStepsList(who, input[0]);
        else
            closed := 1;
        endif

        sleepms(2);
    endwhile
endprogram


function DoDynamicEventList(who, input)
    case (input[0])
        GF_ADDEVENT_BTN:
            var dynamicevent_name := RequestGump(who, "Nome do novo Dynamic Event", "Obrigatório um nome ainda não usado.", "", CANCEL_BTN_ON);
            var group_list := LoadDynamicGroupData().Keys();
            if (dynamicevent_name == 0 || !dynamicevent_name || dynamicevent_name == " " )
                break;
            elseif (dynamicevent_name in group_list)
                selected_dynamicevent := dynamicevent_name;
                break;
            endif
            // group_list := group_list;
            GetSpotGroupData(dynamicevent_name);
            SetElemButton(dynamicevent_name);
            break;
        GF_DELEVENT_BTN:
            RemoveSpotGroupData(selected_dynamicevent);
            SetElemButton(0);
            break;

        default:
            var key_index := input[0]-GF_SELECTELEM_BTN;
            SetElemButton(key_index);
            break;
    endcase
endfunction


function SetElemButton(key_index)
   if (TypeOf(key_index) == "Integer")
      selected_dynamicevent := dynamiceventgroups[key_index];
   else
      selected_dynamicevent := key_index;
   endif

   selected_condition := 0;
   selected_event := 0;
endfunction

function DoEventList(who, input)
    case (input[0])
        GF_ADDEVENT_BTN:
            var choose := RadioGump(who, 0, 0, "Escolha um evento:", event_options);
            var events := GetStepsFor(choose);

            var new_event := struct{"name" := choose, "steps" := events};

            break;
        GF_DELEVENT_BTN:
            RemoveEventData(selected_dynamicevent, selected_event);
            selected_event := 0;

            break;
        default:
            var key_index := input[0]-GF_SELECTEVENT_BTN;
            selected_condition := 0;
            selected_event := key_index;
            break;
    endcase
endfunction

function DoConditionList(who, input)
    case (input[0])
        GF_ADDCONDITION_BTN:
            var choose := RadioGump(who, 0, 0, "Escolha uma condição:", condition_options);
            var events := GetStepsFor(choose);

            var new_condition := struct{"name" := choose, "steps" := events};
            break;
        GF_DELCONDITION_BTN:
            RemoveConditionData(selected_dynamicevent, selected_condition);
            selected_condition := 0;
            break;

        default:
            var key_index := input[0]-GF_SELECTCONDITION_BTN;
            selected_condition := key_index;
            selected_event := 0;
            break;
    endcase
endfunction


// var event_options := array{"Summon Mobs", "Create Item", "Change Environment", "Destroy Item", "Apply TimedScript"};
// var condition_options := array{"Minimum Players", "Mobiles Died", "Boss Died", "Every Second", "Battle Started", "% of Chance", "Player Class"};

function GetStepsFor(event_type)
   var input_request := array{};
   var events := array{};
   case (event_type)
      event_options[1]: // summon
         events.append(struct{ "template" := ":ghaia:" });
         events.append(struct{ "number" := 1 });
         events.append(struct{ "location" := array{0, 0, 0} });
         events.append(struct{ "go_to" := array{0, 0, 0} });

         break;
      event_options[2]: //create item
         events.append(struct{ "item" := struct{"desc" := "Nenhum"} });
         events.append(struct{ "location" := array{0, 0, 0} });
         events.append(struct{ "container" := 0 });
         // do nothing
         break;
      event_options[3]:  //change environment
         break;
      event_options[4]: // destroyitem
         break;
      event_options[5]:  //applytimed
         events.append(struct{ "timedscript" := "" });
         events.append(struct{ "resist_test" := CONSTITUTION });
         events.append(struct{ "chance" := 100 });
         break;

      condition_options[1]: //minimum player
         events.append(struct{ "number" := 1 });
         events.append(struct{ "location" := array{0, 0, 0} });
         events.append(struct{ "range" := 10 });

         break;
      condition_options[2]: //mobiles died
         events.append(struct{ "number" := 1 });
         break;
      condition_options[3]: //boss died
         break;
      condition_options[4]: //every second
         events.append(struct{ "number" := 120 });
         break;
      condition_options[5]: //battle started
         events.append(struct{ "location" := array{0, 0, 0} });
         events.append(struct{ "range" := 10 });
         return;
      condition_options[6]: //% of chance
         events.append(struct{ "number" := 100 });
         break;
      condition_options[7]: //player class
         events.append(struct{ "haveclass" := "Mago" });
         events.append(struct{ "range" := 10 });
         break;
      condition_options[8]: //Light near
         events.append(struct{ "location" := array{0, 0, 0} });
         events.append(struct{ "number" := 1 });
         events.append(struct{ "range" := 10 });
   endcase

   return events;
endfunction

function ChangeStep(who, step_type)
   case (step_type)
      "location":
         SendSysMessageEx(who, "Selecione o local", SSM_REQUEST);
         var targ := TargetCoordinates(who);
         return targ;
      "haveclass":
         return RadioGump(who, 0, 0, "Escolha uma classe:", array{"Mago", "Clérigo", "Guerreiro", "Ladino"});
      "timedscript":
         var timedcfg := TS_GetCfgFile();
         return RadioGump(who, 0, 0, "Escolha um timedscript:", GetConfigStringKeys(timedcfg));
      "resist_test":
         return RadioGump(who, 0, 0, "Escolha um teste:", array{STRENGTH, INTELLIGENCE, DEXTERITY, CONSTITUTION, WISDOM});
   endcase
endfunction

function ChooseLocation(who, many)
   var loc := array{};
   while (1)
      var targ := TargetCoordinates(who);

      if (targ)
         loc.append(array{ loc.x, loc.y, loc.z});
      elseif (!targ && loc.size() > 0)
         break;
      elseif (!many && loc.size() > 0)
         break;
      endif
   endwhile

   return loc;
endfunction

function EventParameters(event, conditions)
// QuestionsGump(who, questions)
endfunction

function ConstructGump()
    dynamiceventgroups := DFGetElemNames(LoadDynamicGroupData()); //Reset every time the Gump is created
    var gump := GFCreateGump(150, 150);
    GFPage(gump, 0);
    GFSetID(gump, gumpid);

    if (selected_dynamicevent)
        ConstructDyanmicEventConfig(gump); //second menu
    endif

    if (selected_event || selected_condition)
        ConstructEventConfig(gump);
    endif

    ConstructGroupList(gump);

    GFoptimizeGump(gump);
    return gump;
endfunction

function ConstructGroupList(byref gump)
    GFResizePic(gump, 15, 15, GFCfgConst("BackGrounds", "TRINKED_HARD_PAPER"), 180, 450);
    GFTextLine(gump, 48, 23, 555, "Dynamic Group List");

    var page     := 1;
    var max_page := 10;
    for i:=1 to dynamiceventgroups.Size()+1
        GFPage(gump, page);
        var x := 50;
        var y := (30+(18*i)); // (((page-1) * max_page)+1); //(BaseX(Espaï¿½amento*i)) / (Calculo de Pagina)

        var color := 1153;
        if (selected_dynamicevent == dynamiceventgroups[i])
            color := 2103;
        endif
        if (dynamiceventgroups[i])
            GFTextLine(gump, x, y, color, dynamiceventgroups[i]);
            GFAddButton(gump, x-14, y+5, 2103, 2104, GF_CLOSE_BTN, GF_SELECTELEM_BTN+i);
        else
            GFTextLine(gump, x+70, y, 1153, "Adicionar");
            GFAddButton(gump, x+70-14, y+5, 0x939, 0x939, GF_CLOSE_BTN, GF_ADD_BTN);

            if (selected_dynamicevent)
                GFTextLine(gump, x+70, y+18, 1153, "Remover");
                GFAddButton(gump, x+70-14, y+18+5, 0x938, 0x938, GF_CLOSE_BTN, GF_DEL_BTN);
            endif
        endif

         //change page
        if (i == (page+1) * max_page)
            page += 1;
        endif
    endfor
endfunction


function ConstructDyanmicEventConfig(byref gump)
    GFPage(gump, 0);
    var group_data  := GetDynamicEventData(selected_dynamicevent);
    // var groupdata_size := group_data.Size();
    var events     := group_data.spawngroup_list;
    var conditions := group_data.spots;
    var form_size  := events.Size() + conditions.Size();

    GFResizePic(gump, 180, 15, GFCfgConst("BackGrounds", "TRINKED_PAPER"), 220, 180+(form_size*18));
    GFTextLine(gump, 202, 28, 555, "Configurações do Grupo");

   //  GFTextLine(gump, 210, 50, 1153, "Ativado:");
   //  GFCheckBox(gump, 210+50, 50+5, 2360, 2361, group_data.active, GF_GROUP_ACTIVE_SWITCH);

    //Create Spots Menu
    GFTextLine(gump, 202, 50+18, 555, "Lista de Eventos");
    var x := 70;
    var base_y := 68+18+18;
    for i:=0 to events.Size();
        var y := (base_y+(18*i));;
        var n := i+1;
        var spot := SystemFindObjectBySerial(events[n]);

        if (events[n])
            //Start Button Change Color and Icon
            var start_button := 0x2622;
            var color := 1153;
            if (n == selected_event)
                start_button := 0x2623;
                color := 2103;
            endif
            //endbutton

            GFTextLine(gump, x, y, color, spot.name);
            GFAddButton(gump, x-20, y+2, start_button, 0x2623, GF_CLOSE_BTN, GF_SELECTEVENT_BTN+n);
        else
            if (events.Size() <= 10)
                GFTextLine(gump, x+30, y, 1153, "Adicionar");
                GFAddButton(gump, x+30-14, y+5, 0x939, 0x939, GF_CLOSE_BTN, GF_ADDEVENT_BTN);
            endif
            if (selected_event)
                GFTextLine(gump, x+110, y, 1153, "Remover");
                GFAddButton(gump, x+110-14, y+5, 0x938, 0x938, GF_CLOSE_BTN, GF_DELEVENT_BTN);
            endif
        endif

        if (i == events.Size())
            base_y := y+32; //start Y for the next menu
        endif
    endfor

    //Create SpawnGroup Menu
    GFTextLine(gump, 202, base_y, 555, "Lista de Condições");
    base_y += 18;
    for i:=0 to conditions.Size();
        var y := (base_y+(18*i));;
        var n := i+1;

        if (conditions[n])
            var spawngroup := GetSpawnGroupData(conditions[n].name, 0); 
            //Start Button Change Color and Icon
            var start_button := 0x2622;
            var color := 1153;
            if (n == selected_condition)
                start_button := 0x2623;
                color := 2103;
            endif

            if (!spawngroup)
                color := 337;
            endif
            //endbutton

            GFTextLine(gump, x, y, color, conditions[n].name);
            GFAddButton(gump, x-20, y+2, start_button, 0x2623, GF_CLOSE_BTN, GF_SELECTCONDITION_BTN+n);
        else
            if (conditions.Size() <= 10)
                GFTextLine(gump, x+30, y, 1153, "Adicionar");
                GFAddButton(gump, x+30-14, y+5, 0x939, 0x939, GF_CLOSE_BTN, GF_ADDCONDITION_BTN);
            endif
            if (selected_condition)
                GFTextLine(gump, x+110, y, 1153, "Remover");
                GFAddButton(gump, x+110-14, y+5, 0x938, 0x938, GF_CLOSE_BTN, GF_DELCONDITION_BTN);
            endif
        endif
    endfor
endfunction


function ConstructEventConfig(byref gump)
   GFPage(gump, 0);
   var group_data;
   var title;
   if (selected_event)
      group_data := GetSpawnGroupData(selected_dynamicevent).events;
      title := "Event";
   else
      group_data := GetSpawnGroupData(selected_dynamicevent).conditions;
      title := "Condition";
   endif

   var event := group_data[event];
   GFResizePic(gump, 415, 15, GFCfgConst("BackGrounds", "TRINKED_HARD_PAPER"), 220, 120+event.steps.size());
   GFTextLine(gump, 490, 28, 555, "{} Configuration".format(event.type));

   var sy := 45;
   var sx := 450;

   config_struct := event.steps;

   foreach ev in (config_struct.keys())
      if (ev.template)
         GFTextLine(gump, sx, sy, 1153, "Template:");
         ev.template := GFTextEntry(gump, sx+40, sy, 120, 18, 2103, ev.template);
      elseif (ev.spawngroup)
         GFTextLine(gump, sx, sy, 1153, "SpawnGroup:");
         ev.spawngroup := GFTextEntry(gump, sx+40, sy, 120, 18, 2103, ev.spawngroup);
      elseif (ev.number)
         GFTextLine(gump, sx, sy, 1153, "Number:");
         ev.number := GFTextEntry(gump, sx+40, sy, 120, 18, 2103, ev.number);
      
      elseif (ev.location)
         GFTextLine(gump, sx, sy, 1153, "Location:");
         GFTextLine(gump, sx+65, sy, 2103, "{}".format(ev.location));
         GFAddButton(gump, sx+52, sy+6, 2103, 2104, GF_CLOSE_BTN, GF_EVENT_BTN+_ev_iter);

      elseif (ev.go_to)
         GFTextLine(gump, sx, sy, 1153, "Go to:");
         GFTextLine(gump, sx+65, sy, 2103, "{}".format(ev.go_to));
         GFAddButton(gump, sx+52, sy+6, 2103, 2104, GF_CLOSE_BTN, GF_EVENT_BTN+_ev_iter);


      // Create Item
      elseif (ev.environment)
         GFTextLine(gump, sx, sy, 1153, "Clima:");
         GFTextLine(gump, sx+65, sy, 2103, "{}".format(ev.environment));
         GFAddButton(gump, sx+52, sy+6, 2103, 2104, GF_CLOSE_BTN, GF_EVENT_BTN+_ev_iter);

      elseif (ev.range)
         GFTextLine(gump, sx, sy, 1153, "Range:");
         ev.range := GFTextEntry(gump, sx+40, sy, 120, 18, 2103, ev.range);

      elseif (ev.haveclass)
         GFTextLine(gump, sx, sy, 1153, "Have class:");
         GFTextLine(gump, sx+65, sy, 2103, "{}".format(ev.haveclass));
         GFAddButton(gump, sx+52, sy+6, 2103, 2104, GF_CLOSE_BTN, GF_EVENT_BTN+_ev_iter);

      elseif (ev.item)
         GFTextLine(gump, sx, sy, 1153, "Item:");
         GFTextLine(gump, sx+65, sy, 2103, "{}".format(ev.item.desc));
         GFAddButton(gump, sx+52, sy+6, 2103, 2104, GF_CLOSE_BTN, GF_EVENT_BTN+_ev_iter);
      endif

      sy+=20;
      sleepms(2);
   endforeach

    GFAddButton(gump, 500, sy+18+40+18, 0xEF, 0xF0, 1, GF_EVENT_UPDATE_BTN);
    GFAddButton(gump, 500, sy+18+60+20+28, 0xEF, 0xF0, 1, GF_EVENT_CHANGE_BTN);
endfunction

function EventSetConfigs(byref who, byref input)
    var event_entry   := struct{};

    case ( input[0] )
        GF_BOSS_BTN: 
            CreateBossStructGump(who, mob_bossparams);
            break;
        GF_DAYTIME_BTN:
            var daytime := CheckBoxGump(who, 150, 165, "Horário de Spawn:", array{"Noite", "Dia", "Lua Nova"});
            if (daytime.Size() > 1)
                mob_daytime := "always";
            else
                mob_daytime := lower(daytime[1]);
            endif
            break;
        GF_POWER_BTN:
            mob_power := cint(RadioGump(who, 150, 165, "Nivel de Poder:", array{"1", "2", "3"}));
            break;
        GF_TYPE_BTN:
            mob_type := lower(RadioGump(who, 190, 180, "Tipo de Monstro:", array{"Melee", "Ranged", "Spellcaster", "Boss"}));
            break;
         GF_MGROUP_BTN:
            mob_group := cint(RadioGump(who, 150, 185, "Grupo:", array{"0", "1", "2", "3"}));
            break;
    endcase

    event_entry.+name       := GFExtractData(input, mob_name);
    event_entry.+power      := mob_power;
    event_entry.+daytime    := mob_daytime;
    event_entry.+isBoss     := input[INPUT_ISBOSS];
    event_entry.+bossParams  := mob_bossparams;
    event_entry.+type       := mob_type;
    event_entry.+mobgroup       := mob_group;

    UpdateGroupMobData(selected_dynamicevent, event_entry, selected_mob);

    SendSysMessageEx(who, "Mob atualizado no spawnGroup!");

endfunction