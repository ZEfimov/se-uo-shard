
use uo;
use datafile;
use basic;

include ":yggdrasil:spawnGroup";
include ":yggdrasil:dynamicevents";
// include ":ghaia:ghaiaUtil";
include ":gumps:requestgump";
include ":gumps:gumps_ex";
include ":gumps:yesno";
include ":tn:tngumps";
include "include/say";
include ":unicos:item_template";

//Main Menu
const GF_GROUP_ACTIVE_SWITCH := 886;
const GF_ADD_BTN        := 888;
const GF_DEL_BTN        := 887;
const GF_SELECTELEM_BTN := 100;

//Moblist menu
const GF_ADDEVENT_BTN     := 889;
const GF_DELEVENT_BTN     := 890;
const GF_SELECTEVENT_BTN := 200;

//Moblist menu
const GF_ADDCONDITION_BTN    := 891;
const GF_DELCONDITION_BTN    := 892;
const GF_SELECTCONDITION_BTN := 300;

//
const GF_EVENT_UPDATE_BTN := 893;
const GF_EVENT_CHANGE_BTN := 894;

const GF_EVENT_BTN := 400;

//Basic
var selected_dynamicevent := ""; //Name of the Elem
var selected_event        := ""; //Name of the spawngroup
var selected_condition    := ""; //Name of the spawngroup
var config_struct;
var dynamiceventgroups;
var gumpid := 0x1F9;

program spotGroups(params)
    var who;
    if (TypeOf(params) != "Array")
        who := params;
        params := 0;
    else
        who := params[1];
        params := params[2];
    endif

    CloseGump(who, gumpid);
    if (params)
        selected_dynamicevent      := params.dynamicevent; //Name of the Elem
    endif

    var closed := 0;
    while (closed != 1)
        var gump := ConstructGump();
        var input := GFSendGump(who, gump);

        if (selected_dynamicevent)
            // var active_switch := GFExtractData(input, GF_GROUP_ACTIVE_SWITCH);
            // if (!active_switch || active_switch == error)
            //     active_switch := 0;
            // endif
            // SetSpotGroupData(selected_dynamicevent, struct{"active":=active_switch});
        endif

        if (selected_event)
            // var spawnpoint := SystemFindObjectBySerial(selected_spawnpoint);
            // var new_spawnpoint := struct{
            //     "name"       := GFExtractData(input, spawnpoint_name),
            //     "mob_number" := GFExtractData(input, spawnpoint_mobnumber),
            //     "range"      := GFExtractData(input, spawnpoint_range)
            // };
            // spawnpoint.SetProps(new_spawnpoint);
        endif

        if (selected_condition)
            // var active_switch := GFExtractData(input, GF_SPOT_ACTIVE_SWITCH);
            // if (!active_switch || active_switch == error)
            //     active_switch := 0;
            // endif
            // var spot := SystemFindObjectBySerial(selected_spot);
            // var new_spot := struct{
            //     "active" := active_switch,
            //     "name" := GFExtractData(input, spot_name),
            //     "evententry" := GFExtractData(input, spot_evententry),
            //     "timeinterval" := GFExtractData(input, spot_timeinterval)
            // };
            // spot.SetProps(new_spot);
        endif

        if ((input[0] >= 900 && input[0] < 910) || (input[0] >= 50 && input[0] < 300))
      //       DoGroupList(who, input[0]);
      //   elseif ((input[0] >= 910 && input[0] < 920) || (input[0] >= 300 && input[0] < 400))
      //       DoSelectedGroupList(who, input[0]);
      //   elseif ((input[0] >= 920 && input[0] < 930) || (input[0] >= 400 && input[0] < 450))
      //       DoSpotList(who, input[0]);
      //   elseif (input[0] >= 930 && input[0] < 940)
      //       DoSpawnPointList(who, input[0]);
      //   elseif (input[0] >= 1000 && input[0] < 1040)
      //       DoTreasureList(who, input[0]);
        else
            closed := 1;
        endif

        sleepms(2);
    endwhile
endprogram

function ConstructGump()
    dynamiceventgroups := DFGetElemNames(LoadDynamicGroupData()); //Reset every time the Gump is created
    var gump := GFCreateGump(150, 150);
    GFPage(gump, 0);
    GFSetID(gump, gumpid);

    if (selected_dynamicevent)
        ConstructDyanmicEventConfig(gump); //second menu
    endif

    if (selected_event || selected_condition)
        ConstructEventConfig(gump);
    endif

    ConstructGroupList(gump);

    GFoptimizeGump(gump);
    return gump;
endfunction

function ConstructGroupList(byref gump)
    GFResizePic(gump, 15, 15, GFCfgConst("BackGrounds", "TRINKED_HARD_PAPER"), 180, 450);
    GFTextLine(gump, 48, 23, 555, "Dynamic Group List");

    var page     := 1;
    var max_page := 10;
    for i:=1 to dynamiceventgroups.Size()+1
        GFPage(gump, page);
        var x := 50;
        var y := (30+(18*i)); // (((page-1) * max_page)+1); //(BaseX(Espaï¿½amento*i)) / (Calculo de Pagina)

        var color := 1153;
        if (selected_dynamicevent == dynamiceventgroups[i])
            color := 2103;
        endif
        if (dynamiceventgroups[i])
            GFTextLine(gump, x, y, color, dynamiceventgroups[i]);
            GFAddButton(gump, x-14, y+5, 2103, 2104, GF_CLOSE_BTN, GF_SELECTELEM_BTN+i);
        else
            GFTextLine(gump, x+70, y, 1153, "Adicionar");
            GFAddButton(gump, x+70-14, y+5, 0x939, 0x939, GF_CLOSE_BTN, GF_ADD_BTN);

            if (selected_dynamicevent)
                GFTextLine(gump, x+70, y+18, 1153, "Remover");
                GFAddButton(gump, x+70-14, y+18+5, 0x938, 0x938, GF_CLOSE_BTN, GF_DEL_BTN);
            endif
        endif

         //change page
        if (i == (page+1) * max_page)
            page += 1;
        endif
    endfor
endfunction


function ConstructDyanmicEventConfig(byref gump)
    GFPage(gump, 0);
    var group_data  := GetDynamicEventData(selected_dynamicevent);
    // var groupdata_size := group_data.Size();
    var events     := group_data.spawngroup_list;
    var conditions := group_data.spots;
    var form_size  := events.Size() + conditions.Size();

    GFResizePic(gump, 180, 15, GFCfgConst("BackGrounds", "TRINKED_PAPER"), 220, 180+(form_size*18));
    GFTextLine(gump, 202, 28, 555, "Configurações do Grupo");

   //  GFTextLine(gump, 210, 50, 1153, "Ativado:");
   //  GFCheckBox(gump, 210+50, 50+5, 2360, 2361, group_data.active, GF_GROUP_ACTIVE_SWITCH);

    //Create Spots Menu
    GFTextLine(gump, 202, 50+18, 555, "Lista de Eventos");
    var x := 70;
    var base_y := 68+18+18;
    for i:=0 to events.Size();
        var y := (base_y+(18*i));;
        var n := i+1;
        var spot := SystemFindObjectBySerial(events[n]);

        if (events[n])
            //Start Button Change Color and Icon
            var start_button := 0x2622;
            var color := 1153;
            if (n == selected_event)
                start_button := 0x2623;
                color := 2103;
            endif
            //endbutton

            GFTextLine(gump, x, y, color, spot.name);
            GFAddButton(gump, x-20, y+2, start_button, 0x2623, GF_CLOSE_BTN, GF_SELECTEVENT_BTN+n);
        else
            if (events.Size() <= 10)
                GFTextLine(gump, x+30, y, 1153, "Adicionar");
                GFAddButton(gump, x+30-14, y+5, 0x939, 0x939, GF_CLOSE_BTN, GF_ADDEVENT_BTN);
            endif
            if (selected_event)
                GFTextLine(gump, x+110, y, 1153, "Remover");
                GFAddButton(gump, x+110-14, y+5, 0x938, 0x938, GF_CLOSE_BTN, GF_DELEVENT_BTN);
            endif
        endif

        if (i == events.Size())
            base_y := y+32; //start Y for the next menu
        endif
    endfor

    //Create SpawnGroup Menu
    GFTextLine(gump, 202, base_y, 555, "Lista de Condições");
    base_y += 18;
    for i:=0 to conditions.Size();
        var y := (base_y+(18*i));;
        var n := i+1;

        if (conditions[n])
            var spawngroup := GetSpawnGroupData(conditions[n].name, 0); 
            //Start Button Change Color and Icon
            var start_button := 0x2622;
            var color := 1153;
            if (n == selected_condition)
                start_button := 0x2623;
                color := 2103;
            endif

            if (!spawngroup)
                color := 337;
            endif
            //endbutton

            GFTextLine(gump, x, y, color, conditions[n].name);
            GFAddButton(gump, x-20, y+2, start_button, 0x2623, GF_CLOSE_BTN, GF_SELECTCONDITION_BTN+n);
        else
            if (conditions.Size() <= 10)
                GFTextLine(gump, x+30, y, 1153, "Adicionar");
                GFAddButton(gump, x+30-14, y+5, 0x939, 0x939, GF_CLOSE_BTN, GF_ADDCONDITION_BTN);
            endif
            if (selected_condition)
                GFTextLine(gump, x+110, y, 1153, "Remover");
                GFAddButton(gump, x+110-14, y+5, 0x938, 0x938, GF_CLOSE_BTN, GF_DELCONDITION_BTN);
            endif
        endif
    endfor
endfunction


function ConstructEventConfig(byref gump)
   GFPage(gump, 0);
   var group_data;
   var title;
   if (selected_event)
      group_data := GetSpawnGroupData(selected_dynamicevent).events;
      title := "Event";
   else
      group_data := GetSpawnGroupData(selected_dynamicevent).conditions;
      title := "Condition";
   endif

   var event := group_data[event];
   GFResizePic(gump, 415, 15, GFCfgConst("BackGrounds", "TRINKED_HARD_PAPER"), 220, 120+event.steps.size());
   GFTextLine(gump, 490, 28, 555, "{} Configuration".format(event.type));

   var sy := 45;
   var sx := 450;

   config_struct := event.steps;

   GFTextLine(gump, sx, sy, 1153, "Nome:");
   config_struct.name := GFTextLine(gump, sx+40, sy, 2103, config_struct.name);
   
   sy += 18;

   foreach ev in (config_struct.keys())
      if (ev.template)
         GFTextLine(gump, sx, sy, 1153, "Template:");
         ev.template := GFTextEntry(gump, sx+40, sy, 120, 18, 2103, ev.template);
      elseif (ev.spawngroup)
         GFTextLine(gump, sx, sy, 1153, "SpawnGroup:");
         ev.spawngroup := GFTextEntry(gump, sx+40, sy, 120, 18, 2103, ev.spawngroup);
      elseif (ev.number)
         GFTextLine(gump, sx, sy, 1153, "Number:");
         ev.number := GFTextEntry(gump, sx+40, sy, 120, 18, 2103, ev.number);
      
      elseif (ev.location)
         GFTextLine(gump, sx, sy, 1153, "Location:");
         GFTextLine(gump, sx+65, sy, 2103, "{}".format(ev.location));
         GFAddButton(gump, sx+52, sy+6, 2103, 2104, GF_CLOSE_BTN, GF_EVENT_BTN+_ev_iter);

      elseif (ev.go_to)
         GFTextLine(gump, sx, sy, 1153, "Go to:");
         GFTextLine(gump, sx+65, sy, 2103, "{}".format(ev.go_to));
         GFAddButton(gump, sx+52, sy+6, 2103, 2104, GF_CLOSE_BTN, GF_EVENT_BTN+_ev_iter);


      // Create Item
      elseif (ev.environment)
         GFTextLine(gump, sx, sy, 1153, "Clima:");
         GFTextLine(gump, sx+65, sy, 2103, "{}".format(ev.environment));
         GFAddButton(gump, sx+52, sy+6, 2103, 2104, GF_CLOSE_BTN, GF_EVENT_BTN+_ev_iter);

      elseif (ev.lightnear)
         GFTextLine(gump, sx, sy, 1153, "Have light:");
         GFTextLine(gump, sx+65, sy, 2103, "{}".format(ev.lightnear));
         GFAddButton(gump, sx+52, sy+6, 2103, 2104, GF_CLOSE_BTN, GF_EVENT_BTN+_ev_iter);

      elseif (ev.range)
         GFTextLine(gump, sx, sy, 1153, "Range:");
         ev.range := GFTextEntry(gump, sx+40, sy, 120, 18, 2103, ev.range);
      elseif (ev.haveclass)
         GFTextLine(gump, sx, sy, 1153, "Have class:");
         GFTextLine(gump, sx+65, sy, 2103, "{}".format(ev.haveclass));
         GFAddButton(gump, sx+52, sy+6, 2103, 2104, GF_CLOSE_BTN, GF_EVENT_BTN+_ev_iter);
      endif

      sy+=20;
      sleepms(2);
   endforeach

    GFAddButton(gump, 500, sy+18+40+18, 0xEF, 0xF0, 1, GF_EVENT_UPDATE_BTN);
    GFAddButton(gump, 500, sy+18+60+20+28, 0xEF, 0xF0, 1, GF_EVENT_CHANGE_BTN);
endfunction

function EventSetConfigs(byref who, byref input)
    var event_entry   := struct{};

    case ( input[0] )
        GF_BOSS_BTN: 
            CreateBossStructGump(who, mob_bossparams);
            break;
        GF_DAYTIME_BTN:
            var daytime := CheckBoxGump(who, 150, 165, "Horário de Spawn:", array{"Noite", "Dia", "Lua Nova"});
            if (daytime.Size() > 1)
                mob_daytime := "always";
            else
                mob_daytime := lower(daytime[1]);
            endif
            break;
        GF_POWER_BTN:
            mob_power := cint(RadioGump(who, 150, 165, "Nivel de Poder:", array{"1", "2", "3"}));
            break;
        GF_TYPE_BTN:
            mob_type := lower(RadioGump(who, 190, 180, "Tipo de Monstro:", array{"Melee", "Ranged", "Spellcaster", "Boss"}));
            break;
         GF_MGROUP_BTN:
            mob_group := cint(RadioGump(who, 150, 185, "Grupo:", array{"0", "1", "2", "3"}));
            break;
    endcase

    event_entry.+name       := GFExtractData(input, mob_name);
    event_entry.+power      := mob_power;
    event_entry.+daytime    := mob_daytime;
    event_entry.+isBoss     := input[INPUT_ISBOSS];
    event_entry.+bossParams  := mob_bossparams;
    event_entry.+type       := mob_type;
    event_entry.+mobgroup       := mob_group;

    UpdateGroupMobData(selected_dynamicevent, event_entry, selected_mob);

    SendSysMessageEx(who, "Mob atualizado no spawnGroup!");

endfunction